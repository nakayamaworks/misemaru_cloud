<!DOCTYPE html>
<html lang="ja">
<head>
  <?!= head ?>
  <?!= commonJs ?>
  <?!= commonCss ?>
  <script>
    const baseUrl = "<?= baseUrl ?>";
  </script>
  <title>📅 予約管理（空き状況カレンダー）</title>
 <style>
 /* 表全体 */
  .table {
    margin: 0;
    border-collapse: separate;
    border-spacing: 0;
    width: 100%;
  }

  .table-wrap {
    overflow: auto;
    max-height: 80vh;
    position: relative;
    border: 2px solid #ccc;
    border-radius: 6px;
    background-color: #fff;
    padding: 0 !important;
  }

  @supports (height: 100dvh) {
    .table-wrap { max-height: 80dvh; }
  }

  .table th, .table td {
    background-color: #fff;
    height: var(--slot-height);
    max-height: var(--slot-height);
    box-shadow: inset -1px 0 #dee2e6,  /* 左 */
      inset 1px 0 #dee2e6,   /* 右 */
      inset 0 -1px #dee2e6,  /* 下 */
      inset 0 1px #dee2e6;   /* 上 */
  }

  /* 実線・点線 */
  .border-solid {
    border-top: 1px solid #999 !important;
  }
  .border-dotted {}

  /* 固定セル */
  .table th[rowspan="2"]:first-child {
    position: sticky;
    top: 0;
    left: 0;
    z-index: 1000;
    height: 72px;
    vertical-align: middle;
    text-align: center;
    padding: 0.4rem;
  }

  .table thead tr:first-child th {
    position: sticky;
    top: 0;
    z-index: 900;
    height: 36px;
    padding: 0.4rem;
  }

  .table thead tr:nth-child(2) th {
    position: sticky;
    top: 36px;
    z-index: 800;
    height: 36px;
    padding: 0.4rem;
    font-size: 0.75rem;
    line-height: 1.4;
  }

  .table td:first-child {
    position: sticky;
    left: 0;
    top: 72px;
    z-index: 700;
    padding: 0.4rem;
  }

  .table th, .table td {
    min-width: 90px;
    max-width: 90px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    text-align: center;
    vertical-align: middle;
    font-size: 0.85rem;
    line-height: 1.4;
  }

  /* スマホ向け調整 */
  @media (max-width: 576px) {
    #display-mode-toggle .btn,
    .calendar-wrapper .btn,
    .d-flex.justify-content-center .btn {
      font-size: 0.9rem;
      padding: 0.25rem 0.5rem;
    }
    .calendar-wrapper input[type="date"] {
      width: 30px;
      height: 32px;
    }
    #week-label { font-size: 0.9rem; }
    .table-wrap { overflow-x: auto; -webkit-overflow-scrolling: touch; }
    .table { table-layout: fixed !important; }
    .table th, .table td {
      min-width: 48px !important;
      max-width: 48px !important;
      font-size: 0.75rem !important;
      padding: 2px !important;
    }
    .table thead tr:first-child th[colspan] {
      font-size: 0.9rem !important;
      line-height: 1.1;
      white-space: normal;
    }
    .day-split {
      display: block;
      font-size: 0.75rem;
      margin-top: 2px;
      text-align: center;
    }
    .text-danger .day-split { color: #dc3545 !important; }
    .text-primary .day-split { color: #0d6efd !important; }
    .staff-name-cell {
      white-space: normal !important;
      word-break: break-word;
      font-size: 0.65rem;
      line-height: 1.2;
    }
    .vertical-name {
      writing-mode: vertical-rl;
      text-orientation: upright;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      max-height: 5em;
      display: block;
      font-size: 0.75rem;
      line-height: 1;
      margin: 0 auto;
      text-align: center;
    }
  }

  .table th:first-child {
    position: sticky;
    left: 0;
    z-index: 600;
    background-color: #fff;
  }

  td a {
    display: block;
    width: 100%;
    max-width: 100%;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  #display-mode-toggle, #service-tabs,
  #reservation-overlay {
    display: none;
  }

  .selectable-cell { cursor: pointer; }
  td.selectable-cell:hover { background-color: #e6f7ff !important; }

  select option:disabled { color: #aaa; font-style: italic; }
  select option:disabled:hover { background-color: #fff; cursor: not-allowed; }

  .available-slot {
    color: #66bb66 !important;
    font-weight: bold;
  }
  .other-reserved-slot {
    color: #B22D35 !important;
    font-weight: bold;
  }

  /* タブ */
  .tab-bar {
    display: flex;
    justify-content: flex-start;
    border-bottom: none;
    background-color: #e3f4fd;
    padding: 0 0.5rem;
    gap: 0.25rem;
  }
  .tab-bar button {
    font-size: 0.8rem;
    border: 1px solid #ccc;
    border-bottom: none;
    border-radius: 0.5rem 0.5rem 0 0;
    background-color: #e9ecef;
    padding: 6px 12px;
    font-weight: 500;
    color: #333;
    transition: background-color 0.2s ease;
    margin-bottom: -1px;
  }
  .tab-bar button:hover { background-color: #dee2e6; }
  .tab-bar .btn-outline-primary:hover {
    border-color: #ccc !important;
    background-color: #e0e0e0;
    color: #000;
  }
  .tab-bar .btn-outline-primary.active {
    background-color: #fff;
    color: #000;
    border-color: #ccc !important;
  }
  .tab-bar button.active {
    background-color: #fff;
    color: #000;
    border-bottom: none !important;
    z-index: 2;
    font-weight: bold;
    position: relative;
    margin-bottom: -1px;
  }
  .tab-wrapper .table-responsive {
    border-top: none;
    margin-top: 0;
    z-index: 1;
    position: relative;
  }


</style>
<?!= commonCss ?>
<style>
  #display-mode-toggle .btn {
    margin-right: 0.5rem;
    opacity: 0.4;
    font-weight: bold;
  }
  #display-mode-toggle .btn.active {
    opacity: 1;
    background-color: #0d6efd;
    color: white;
  }

</style>
</head>
<body class="loading">
  <div id="loading" style="text-align:center; margin-top:50px;">
    <div class="auth-spinner"></div>
    <p>認証チェック中...</p>
  </div>
  <div id="app" style="display:none;">


<div class="container pt-2 py-3">

<!-- ✅ ナビゲーションバー -->
<nav class="navbar navbar-expand-lg navbar-light bg-light mb-3">
  <div class="container-fluid px-0">
    <a class="navbar-brand" onclick="closeToAdmin()">
      <img src="https://raw.githubusercontent.com/WataruNakayama1203/misemaru-cloud-assets/main/misemaru_text_only.png" alt="みせまるクラウド ロゴ" class="top-logo" />
    </a>
    <button class="navbar-toggler ms-auto" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse justify-content-lg-end" id="navbarNav">
      <div class="d-flex flex-column flex-lg-row align-items-center gap-2 mt-2 mt-lg-0">
        <!--<button type="button" class="btn btn-red fw-bold px-3" onclick="goTo('10_availability_staff')">📅 予約管理</button>-->
        <button type="button" class="btn btn-green fw-bold px-3" onclick="goTo('20_staff_main_staff')">👥 スタッフ管理</button>
        <button type="button" class="btn btn-blue fw-bold px-3" onclick="goTo('30_register_staff')">📇 顧客管理</button>
        <button type="button" class="btn btn-gray fw-bold px-3" onclick="goTo('40_setting_main_admin')">🏪 店舗設定</button>
      </div>
    </div>
  </div>
</nav>

  <h5 class="text-center mb-2">📅 予約管理（空き状況カレンダー）</h5>

  <div id="display-mode-toggle" class="text-center mb-2">
    <button id="mode-staff" class="btn btn-outline-secondary">スタッフ</button>
    <button id="mode-service" class="btn btn-outline-secondary active">サービス</button>
  </div>

  <div id="category-main-wrap" class="text-center mb-2" style="display:none;">
    <select id="category-main-select"
            class="form-select form-select-sm d-inline-block"
            style="width:220px;"></select>
  </div>

  <!-- 📆 週ラベル -->
  <div class="text-center mb-2">
    <span id="week-label" class="fs-6"></span>
  </div>

  <!-- ⏮⏭ ナビゲーション -->
  <div class="d-flex justify-content-center align-items-center mb-3 gap-2 flex-wrap">
    <button class="btn btn-outline-secondary" onclick="changeWeek(-7)">＜前週</button>

    <!-- 📅 カレンダーアイコン -->
    <div class="calendar-wrapper" style="position: relative; display: inline-block;">
      <input type="date" id="date-picker"
            style="opacity: 0; position: absolute; top: 0; left: 0; width: 40px; height: 38px; cursor: pointer; z-index: 2;" 
            onchange="handleDateSelect()" />
      <button id="calendar-button" class="btn btn-outline-secondary"
              onclick="document.getElementById('date-picker').focus()">📅</button>
    </div>

    <button class="btn btn-outline-secondary" onclick="changeWeek(7)">次週＞</button>
  </div>
  <!-- ✅ タブ + 表を1つのラッパーにまとめる -->
  <div class="tab-wrapper">
    <!-- 🔁 サービス切替タブ（Chrome風） -->
    <div id="service-tabs" class="tab-bar">
      <!-- JSでボタンが入る -->
    </div>

    <!-- 📅 カレンダー表 -->
    <div id="table-area" class="table-responsive"></div>
  </div>

</div>

<!-- 📅 予約確認モーダル -->
<div class="modal fade" id="viewConfirmModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">予約確認</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body" id="confirm-modal-body">
        <!-- ここに詳細情報を埋め込む -->
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">キャンセル</button>
        <button type="button" class="btn btn-primary" id="edit-reserve-btn">変更</button>
        <button type="button" class="btn btn-danger" id="delete-btn">削除</button>
      </div>
    </div>
  </div>
</div>


<!-- ⚠️ 削除確認モーダル -->
<div class="modal fade" id="confirmDeleteModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title text-danger">本当に削除しますか？</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <p>この予約を削除してもよろしいですか？</p>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="cancel-delete-btn">キャンセル</button>
        <button class="btn btn-danger" id="confirm-delete-btn">削除</button>
      </div>
    </div>
  </div>
</div>

<!--  予約セル用モーダル -->
<!-- 🟢 予約モーダル（統一版） -->
<div class="modal fade" id="viewReserveModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">予約入力</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body" id="reserve-modal-body">
        <!-- 上部に注意文言エリアを追加 -->
        <div id="reserve-warning" class="alert alert-warning p-2 small mb-2 d-none"></div>
        <!-- JSでフォームが埋まる -->
      </div>
      <div class="modal-footer justify-content-between flex-wrap gap-2">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
          キャンセル
        </button>
        <div class="ms-auto d-flex flex-wrap gap-2">
          <button type="button" class="btn btn-primary" id="view-reserve-btn">
            次へ
          </button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- 予約確認モーダル -->
<div class="modal fade" id="reserveConfirmModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">この内容で予約してもよろしいですか？</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body" id="reserve-confirm-body">
        <!-- 上部に注意文言エリアを追加 -->
        <div id="reserve-confirm-warning" class="text-danger mb-2 d-none"></div>
        <!-- JSで詳細が入る -->
        <div id="reserve-confirm-content"></div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" id="back-to-form-btn">戻る</button>
        <button type="button" class="btn btn-primary" id="confirm-reserve-btn">予約</button>
        <button type="button" class="btn btn-success d-none" id="confirm-reserve-register-btn">顧客登録＆予約</button>
      </div>
    </div>
  </div>
</div>


<!-- ⚠️ 入力不足確認モーダル -->
<div class="modal fade" id="inputCheckModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">未入力項目があります</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        姓・名・電話番号のいずれかが未入力です。<br>このまま予約を続けてもよろしいですか？
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">キャンセル</button>
        <button type="button" class="btn btn-primary" id="input-check-ok-btn">OK</button>
      </div>
    </div>
  </div>
</div>

<!--  顧客登録モーダル -->
<div class="modal fade" id="customerRegisterModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-centered">
    <div class="modal-content p-3">
      <div class="modal-header">
        <h5 class="modal-title">📇 顧客登録</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="閉じる"></button>
      </div>
      <div class="modal-body">
         <!-- 🔔 注意文言 -->
        <div class="alert alert-warning p-2 small text-center mb-3">
          ※ この時点ではまだ予約は確定していません。
        </div>
        <form id="customerRegisterForm">
          <div class="row">
            <div class="col-md-6 mb-2">
              <label>姓</label>
              <input type="text" id="regLastName" class="form-control" required>
            </div>
            <div class="col-md-6 mb-2">
              <label>名</label>
              <input type="text" id="regFirstName" class="form-control" required>
            </div>
            <div class="col-md-6 mb-2">
              <label>フリガナ（姓）</label>
              <input type="text" id="regLastKana" class="form-control">
            </div>
            <div class="col-md-6 mb-2">
              <label>フリガナ（名）</label>
              <input type="text" id="regFirstKana" class="form-control">
            </div>
            <div class="col-md-6 mb-2">
              <label>電話番号</label>
              <input type="text" id="regPhone" class="form-control" required>
            </div>
            <div class="col-md-6 mb-2">
              <label>メールアドレス</label>
              <input type="email" id="regEmail" class="form-control">
            </div>
            <div class="col-12 mb-2">
              <label>カットスタイル</label>
              <textarea id="regCutStyle" class="form-control" rows="2"></textarea>
            </div>
            <div class="col-12 mb-2">
              <label>備考</label>
              <textarea id="regNote" class="form-control" rows="2"></textarea>
            </div>
          </div>
        </form>
      </div>
      <div class="modal-footer d-flex justify-content-between">
        <button class="btn btn-secondary" id="backToConfirmReserve">戻る</button>
        <button class="btn btn-primary" id="skipCustomerRegister">スキップして予約</button>
        <button class="btn btn-primary" id="submitCustomerRegister">予約</button>
      </div>
    </div>
  </div>
</div>

<!-- 🕒 アイドルタイムアウトモーダル -->
<div class="modal fade" id="idleModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">⏳ 無操作が続いています</h5>
      </div>
      <div class="modal-body">
        15分間操作がなかったため、<br>10秒後にトップページへ戻ります。
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" id="idleCancelBtn">
          キャンセルしてこのまま続ける
        </button>
      </div>
    </div>
  </div>
</div>

<!-- 予約被り禁止モーダル -->
<div class="modal fade" id="conflictModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content border-danger">
      <div class="modal-header bg-danger text-white">
        <h5 class="modal-title">⚠️ 予約が重複しています</h5>
      </div>
      <div class="modal-body">
        この時間帯はすでに予約が入っているため、登録できませんでした。<br>
        他の時間をお選びください。
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="goTo('10_availability')">ページ再読み込み</button>
      </div>
    </div>
  </div>
</div>


<div id="page-end" style="height: 10px;"></div>

<!-- 🌀予約中のスピナーオーバーレイ -->
<div id="reservation-overlay" class="position-fixed top-0 start-0 w-100 h-100 justify-content-center align-items-center bg-dark bg-opacity-50" style="z-index: 1055; display: none;">
  <div class="text-center text-white">
    <div class="spinner-border" role="status"></div>
    <div class="mt-2 fs-5 overlay-message">予約処理中...</div>
  </div>
</div>

<script>


const prefillDate = '<?= date ?>';
const prefillTime = '<?= time ?>';
let weeklyCache = {}; //全週のデータを保存するキャッシュ
let weeklyDataCache = {}; //	現在表示中の週のデータ
let isLoading = false;
let lastTableData = {};
let lastSelectedDate = "";
let isFirstOpen = true;
let hasHighlightedPrefill = false;
let reservationUnit = 60;
let currentMode = "service";
let isSingleStaffMode = false;
let cachedCustomerList = null;
let isCustomerListReady = false;
let lastReserved = null;
let modalToRestore = null;
let scrollMemory = {};
let lastMatchedCustomer = null;


/*　=============================================================================================== */
/*　                                        日付処理（当日）                                      */
/*　=============================================================================================== */
let currentStartDate = toStartOfDayJST(new Date()); 

// "YYYY-MM-DD" 文字列 or Date を JST 0:00 に揃える
function toStartOfDayJST(input) {
  const d = (input instanceof Date) ? input : new Date(input);
  if (isNaN(d)) return null;
  // JSTタイムゾーンでその日の0時を返す
  return new Date(d.getFullYear(), d.getMonth(), d.getDate());
}

/*　=============================================================================================== */
/*　                                        ページリダイレクト処理                                      */
/*　=============================================================================================== */
const idle = {
  timer: null,       // メインの15分タイマー
  modalTimer: null,  // モーダル出した後の自動遷移タイマー（もし使うなら）
  gen: 0,            // 世代。これが変わったら古いタイマーは無効
  deadline: 0,       // 次のタイムアウト予定時刻（Date.now() で比較）
};

function clearIdleTimers() {
  if (idle.timer) { clearTimeout(idle.timer); idle.timer = null; }
  if (idle.modalTimer) { clearTimeout(idle.modalTimer); idle.modalTimer = null; }
}

function armIdle(limitMs) {
  clearIdleTimers();
  idle.gen++;
  const myGen = idle.gen;
  idle.deadline = Date.now() + limitMs;
  idle.timer = setTimeout(() => {
    if (idle.gen !== myGen) return;  // 古いタイマーなら無視
    showIdleConfirmModal();
  }, limitMs);
}

const IDLE_LIMIT = 120 * 60 * 1000; // 15分　→　120分へ

function resetIdleTimer() {
  armIdle(IDLE_LIMIT);
}

function showIdleConfirmModal() {
  // ここで新しい世代にしておくと、表示直前に仕込まれてた古いタイマーを無効化できる
  idle.gen++;

  // 既存モーダルのクリーンアップ
  const modalEl = document.getElementById("idleModal");
  const modal = new bootstrap.Modal(modalEl, {
    backdrop: 'static',
    keyboard: false
  });

  // ボタンのイベントをつけ直し（多重登録防止）
  const cancelBtn = document.getElementById("idleCancelBtn");
  const gotoBtn = document.getElementById("idleGotoBtn"); // 「TOPへ」ボタンがあるなら

  cancelBtn.onclick = () => {
    // すべてのタイマー無効化＆世代進める
    clearIdleTimers();
    idle.gen++;

    // モーダル閉じる
    modal.hide();

    // バックドロップが残る事故対策
    document.querySelectorAll('.modal-backdrop').forEach(n => n.remove());
    document.body.classList.remove('modal-open');

    // 直ちに新しい締切で再アーム（今ここから15分）
    armIdle(IDLE_LIMIT);
  };

  if (gotoBtn) {
    gotoBtn.onclick = () => {
      clearIdleTimers();
      idle.gen++;
      // closeToAdmin() があるならそっち推奨
      if (typeof closeToAdmin === 'function') closeToAdmin();
      else window.location.href = `${baseUrl}?page=06_index`;
    };
  }

  modal.show();

  // （任意）モーダルを出してからX秒で自動でTOPに戻したいなら
  // 古い modalTimer が残らないよう世代バインド
  const myGen = idle.gen;
  idle.modalTimer = setTimeout(() => {
    if (idle.gen !== myGen) return; // キャンセルで世代が進んだら無視
    if (typeof closeToAdmin === 'function') closeToAdmin();
    else window.location.href = `${baseUrl}?page=06_index`;
  }, 10 * 1000); // 例: 60秒
}

/*　=============================================================================================== */
/*　                                        データフォーマット系                                       */
/*　=============================================================================================== */
// ⏰ 文字列 "HH:mm" → 分に変換
function timeToMinutes(str) {
  const [h, m] = str.split(":").map(Number);
  return h * 60 + m;
}

// ⏰ 分 → "HH:mm" に変換
function minutesToTime(mins) {
  const h = Math.floor(mins / 60).toString().padStart(2, "0");
  const m = (mins % 60).toString().padStart(2, "0");
  return `${h}:${m}`;
}

function formatDateWithWeekday(ymdStr) {
  if (!ymdStr || isNaN(new Date(ymdStr))) {
    return "（日付不明）";
  }

  const d = new Date(ymdStr);
  const day = ["日", "月", "火", "水", "木", "金", "土"][d.getDay()];
  return `${d.getFullYear()}年${d.getMonth() + 1}月${d.getDate()}日(${day})`;
}

//トグルボタンによるサービス切り替え用

// ✅ UIの切り替え処理
document.getElementById("mode-staff").addEventListener("click", () => {
  if (currentMode !== "staff") {
    resetScrollMemory();
    currentMode = "staff";
    setToggleUI("staff");
    localStorage.setItem("calendarMode", "staff");
    initTabs("staff");
  }
});

document.getElementById("mode-service").addEventListener("click", () => {
  if (currentMode !== "service") {
    resetScrollMemory();
    currentMode = "service";
    setToggleUI("service");
    localStorage.setItem("calendarMode", "service");
    initTabs("service");
  }
});

function updateSingleStaffMode(data) {
  isSingleStaffMode = data?.meta?.staffList?.length === 1;
}

// ✅ ボタンの見た目だけ切り替え
function setToggleUI(mode) {
  document.getElementById("mode-staff").classList.toggle("active", mode === "staff");
  document.getElementById("mode-service").classList.toggle("active", mode === "service");
}

/*　=============================================================================================== */
/*　                                        モーダル表示系                                            */
/*　=============================================================================================== */
let pendingHref = "";
let pendingReserveInfo = {}; // 日付・時間・サービスなど

function convertReasonToLabel(reasonText) {
  if (reasonText.includes("営業時間外") || reasonText.includes("担当者が不在")) {
    return "時間外";
  }
  if (reasonText.includes("他サービスの予約")) {
    return "他予約"; // ← 追加！
  }
  if (reasonText.includes("この時間帯にはすでに予約が")) {
    return "予約済";
  }
  return "予約不可"; // それ以外
}

// 開始候補
function getStartTimeCandidates(dateStr, staffId, serviceId) {
  const unit = weeklyDataCache?.meta?.unitMin || 15;

  // まず祝日反映版
  const bizA = weeklyDataCache?.meta?.rawBusinessHoursMap || {};
  let hoursList = bizA[dateStr] || [];

  // 空（=祝日休業など）なら祝日無視版にフォールバック
  if (!Array.isArray(hoursList) || hoursList.length === 0) {
    const bizBase = weeklyDataCache?.meta?.rawBusinessHoursMapBase || {};
    hoursList = bizBase[dateStr] || [];
  }

  const allSlots = new Set();
  for (const hours of hoursList) {
    const startMin = timeToMinutes(hours.start);
    const endMin   = timeToMinutes(hours.end);
    for (let t = startMin; t < endMin; t += unit) {
      allSlots.add(minutesToTime(t));
    }
  }
  return Array.from(allSlots).sort((a, b) => timeToMinutes(a) - timeToMinutes(b));
}


function generateStartTimeOptionsHTML(dateStr, selectedTime, staffId, serviceId, excludeReservation = null) {
  const times = getStartTimeCandidates(dateStr, staffId, serviceId);
  const unit = weeklyDataCache?.meta?.unitMin || 15;

  const excludeDuration = (excludeReservation?.endTime && excludeReservation?.time)
    ? timeToMinutes(excludeReservation.endTime) - timeToMinutes(excludeReservation.time)
    : unit;

  return times.map(t => {
    const tMin = timeToMinutes(t);
    const tEndMin = tMin + excludeDuration;
    const tEnd = minutesToTime(tEndMin);

    const reasons = checkReservationAvailabilityReasons(
      dateStr,
      t,
      tEnd,
      staffId,
      serviceId,
      excludeReservation
    );

    // 🔍 この t に対応する理由だけを見る
    const thisReason = reasons.find(r => r.time === t);
    const shortLabel = thisReason ? convertReasonToLabel(thisReason.reason) : "";

    const isDisabled = ["予約済", "予約不可"].includes(shortLabel);
    const label = shortLabel ? `${t}（${shortLabel}）` : t;

    return `<option value="${t}" ${t === selectedTime ? "selected" : ""} ${isDisabled ? "disabled" : ""}>${label}</option>`;
  }).join("");
}

// 終了候補
function getEndTimeCandidates(startTime, dateStr, staffId, serviceId) {
  const unit = weeklyDataCache?.meta?.unitMin || 15;

  // まず祝日反映版
  const bizA = weeklyDataCache?.meta?.rawBusinessHoursMap || {};
  let hoursList = bizA[dateStr];

  // 空なら祝日無視版
  if (!Array.isArray(hoursList) || hoursList.length === 0) {
    const bizBase = weeklyDataCache?.meta?.rawBusinessHoursMapBase || {};
    hoursList = bizBase[dateStr];
  }

  const startMin = timeToMinutes(startTime);
  const list = [];
  if (Array.isArray(hoursList) && hoursList.length > 0) {
    for (const hours of hoursList) {
      const endMin = timeToMinutes(hours.end);
      for (let t = startMin + unit; t <= endMin; t += unit) {
        list.push(minutesToTime(t));
      }
    }
  }
  return [...new Set(list)];
}


function generateEndTimeOptionsHTML(startTime, dateStr, selectedEndTime, staffId, serviceId, excludeReservation = null) {
  const times = getEndTimeCandidates(startTime, dateStr, staffId, serviceId);
  const unit = weeklyDataCache?.meta?.unitMin || 15;

  let disableFromHere = false;

  return times.map(t => {
    const endMin = timeToMinutes(t);
    const startMin = endMin - unit;
    const startStr = minutesToTime(startMin);

    const reasons = checkReservationAvailabilityReasons(dateStr, startStr, t, staffId, serviceId, excludeReservation);
    const firstReason = reasons.length > 0 ? reasons[0]?.reason || "" : "";
    const shortLabel = firstReason ? convertReasonToLabel(firstReason) : "";

    if (["予約済", "予約不可"].includes(shortLabel)) {
      disableFromHere = true;
    }

    const label = shortLabel ? `${t}（${shortLabel}）` : t;
    const isDisabled = disableFromHere;

    return `<option value="${t}" ${t === selectedEndTime ? "selected" : ""} ${isDisabled ? "disabled" : ""}>${label}</option>`;
  }).join("");
}

function getAdjustedEndTimeForEditMode(startTime, originalEndTime, date, staffId, serviceId, excludeReservation) {
  const unit = weeklyDataCache?.meta?.unitMin || 15;
  const startMin = timeToMinutes(startTime);
  const origEndMin = timeToMinutes(originalEndTime);

  // 編集前より前倒しされたか？
  if (startMin < timeToMinutes(excludeReservation.time)) {
    // 新たな範囲に予約済が含まれていたら再調整
    for (let t = startMin; t < origEndMin; t += unit) {
      const tStr = minutesToTime(t);
      const reasons = checkReservationAvailabilityReasons(
        date,
        tStr,
        minutesToTime(t + unit),
        staffId,
        serviceId,
        excludeReservation
      );

      const label = reasons.length > 0 ? convertReasonToLabel(reasons[0].reason || "") : "";
      if (["予約済", "予約不可"].includes(label)) {
        return findMaxAvailableEndTime(startTime, date, staffId, serviceId, excludeReservation);
      }
    }
    return originalEndTime;
  }

  return originalEndTime;
}

function getAdjustedEndTimeIfInvalid(startTime, endTime, date, staffId, serviceId, excludeReservation) {
  if (timeToMinutes(startTime) >= timeToMinutes(endTime)) {
    const desired = calculateDefaultEndTime(startTime, serviceId);
    const maxAvailable = findMaxAvailableEndTime(startTime, date, staffId, serviceId, excludeReservation);
    if (!maxAvailable || timeToMinutes(desired) <= timeToMinutes(maxAvailable)) {
      return desired;
    }
    return maxAvailable;
  }
  return endTime;
}

//開始時間と終了時間を更新する関数
function updateTimeOptions(excludeReservation = null) {
  const dateStr = document.getElementById("reserve-date").value;
  const staffId = document.getElementById("reserve-staff").value;
  const serviceId = document.getElementById("reserve-service").value;
  const startSelect = document.getElementById("start-time-select");
  const endSelect = document.getElementById("end-time-select");

  if (!dateStr || !staffId || !serviceId) return;

  // 1. 現在の選択状態
  const selectedStartTime = startSelect.value;
  const currentEndTime = endSelect.value;

  // 2. 開始時間オプションを再生成
  startSelect.innerHTML = generateStartTimeOptionsHTML(dateStr, selectedStartTime, staffId, serviceId, excludeReservation);

  // 3. 再取得された開始時間に合わせて終了時間候補生成
  const updatedStartTime = startSelect.value;
  let adjustedEndTime = currentEndTime;

  // 編集モードか？
  const isEdit = excludeReservation && excludeReservation.mode === "edit";

  if (isEdit) {
    adjustedEndTime = getAdjustedEndTimeForEditMode(
      updatedStartTime,
      currentEndTime,
      dateStr,
      staffId,
      serviceId,
      excludeReservation
    );
  }

  // 終了時間の整合性チェック（④のロジック）
  adjustedEndTime = getAdjustedEndTimeIfInvalid(
    updatedStartTime,
    adjustedEndTime,
    dateStr,
    staffId,
    serviceId,
    excludeReservation
  );

  // 4. 終了時間オプションを生成
  endSelect.innerHTML = generateEndTimeOptionsHTML(updatedStartTime, dateStr, adjustedEndTime, staffId, serviceId, excludeReservation);

  // 5. value設定（含まれていなければ最初のoption）
  const endValues = [...endSelect.options].map(opt => opt.value);
  endSelect.value = endValues.includes(adjustedEndTime) ? adjustedEndTime : endValues[0] || "";
}


//日付が変わった時に呼び出す関数
function updateTimeSelectOptions(date, staffId, serviceId, selectedTime = "") {
  const startSelect = document.getElementById("start-time-select");
  const endSelect = document.getElementById("end-time-select");

  const newStartOptions = generateStartTimeOptions(date, staffId, serviceId);
  startSelect.innerHTML = newStartOptions;
  if (selectedTime) startSelect.value = selectedTime;

  const newEndOptions = getEndTimeCandidates(startSelect.value, date, staffId, serviceId)
    .map(t => `<option value="${t}">${t}</option>`)
    .join("");
  endSelect.innerHTML = newEndOptions;
}

function generateServiceOptionsHTML(selectedId) {
  const allServices = weeklyDataCache?.meta?.serviceList || [];
  const services = filterServicesByActiveCategory(allServices); // ← 追加
  return services.map(s =>
    `<option value="${s.id}" ${s.id === selectedId ? "selected" : ""}>
       ${s.categorySub || s.name}
     </option>`
  ).join("");
}

function generateStaffOptionsHTML(selectedId, serviceId) {
  const staffList = weeklyDataCache?.meta?.staffList || [];
  const serviceStaffMap = weeklyDataCache?.meta?.serviceStaffMap || {};

  const allowedStaffIds = serviceStaffMap[serviceId] || [];

  return staffList
    .filter(s => allowedStaffIds.includes(s.id))
    .map(s => `<option value="${s.id}" ${s.id === selectedId ? "selected" : ""}>${s.name}</option>`)
    .join("");
}

function getServiceNameById(serviceId) {
  const services = weeklyDataCache?.meta?.serviceList || [];
  const service = services.find(s => s.id === serviceId);
  return service ? service.name : "-";
}

function getStaffNameById(staffId) {
  const staff = weeklyDataCache?.meta?.staffList || [];
  const s = staff.find(s => s.id === staffId);
  return s ? s.name : "-";
}

function getCurrentWeekRange() {
  const start = toStartOfDayJST(currentStartDate); // 当日0:00
  const end = new Date(start);
  end.setDate(start.getDate() + 6);             // 7日間の最終日
  return { start: formatDate(start), end: formatDate(end) };
}

// ユーティリティ：時刻配列を連続範囲にまとめる
function groupTimeRanges(timeList, unitMin) {
  
  if (timeList.length === 0) return [];

  const timesMin = timeList
    .map(t => ({ str: t, min: timeToMinutes(t) }))
    .filter(t => !isNaN(t.min))  // ← 念のため不正値を除外
    .sort((a, b) => a.min - b.min);

  if (timesMin.length === 0) return [];

  const ranges = [];
  let start = timesMin[0].str;
  let prev = timesMin[0].min;

  for (let i = 1; i < timesMin.length; i++) {
    const curr = timesMin[i];
    if (curr.min !== prev + unitMin) {
      ranges.push({ start, end: minutesToTime(prev + unitMin) });
      start = curr.str;
    }
    prev = curr.min;
  }
  ranges.push({ start, end: minutesToTime(prev + unitMin) });

  const result = ranges.map(r => `${r.start}～${r.end}`);
  return result;
}

function groupReasons(reasonList, unitMin) {
  const grouped = {};

  for (const r of reasonList) {
    if (!r.reason || !r.time) {
      console.warn("⚠️ 不正なreason項目:", r);
      continue;
    }

    if (!grouped[r.reason]) grouped[r.reason] = [];
    grouped[r.reason].push(r.time);
  }

  const lines = [];

  for (const reason in grouped) {
    const ranges = groupTimeRanges(grouped[reason], unitMin);
    if (ranges.length === 0) continue;
    lines.push(`${ranges.join("、")}：${reason}`);
  }
  return lines;
}

function checkReservationAvailabilityReasons(dateStr, startTime, endTime, staffId, serviceId, excludeReservation = null) {
  if (!weeklyDataCache || !weeklyDataCache.staffView) return [{ time: "全体", reason: "データ未取得" }];

  const staffView = weeklyDataCache.staffView[staffId];
  const meta = weeklyDataCache.meta;
  const unit = meta?.unitMin || 15;
  if (!staffView || !staffView[dateStr]) return [{ time: "全体", reason: "該当日のデータがありません" }];

  const slots = staffView[dateStr];

  // 1) そのままの予約件数（自分除外しない）
  const reservedCountMap = new Map();
  for (const tStr in slots) {
    const cells = slots[tStr]?.[serviceId];
    if (!Array.isArray(cells)) continue;
    for (const cell of cells) {
      const status = cell?.status ?? "";
      const sTime = cell?.startTime;
      const eTime = cell?.endTime;
      if (!sTime || !eTime) continue; // 先頭セルだけ持つ前提
      if (["🟢", "−", "×"].includes(status)) continue; // 自サービス予約だけ数える
      const s = timeToMinutes(sTime);
      const e = timeToMinutes(eTime);
      for (let m = s; m < e; m += unit) {
        const key = minutesToTime(m);
        reservedCountMap.set(key, (reservedCountMap.get(key) || 0) + 1);
      }
    }
  }

  // 2) サービスのキャパ
  const serviceMeta = meta?.serviceList?.find(s => s.id === serviceId);
  const capacity = Number(serviceMeta?.capacity) || 1;

  // 3) 編集中の自分の区間
  const isEdit = !!excludeReservation && dateStr === excludeReservation.date;
  const sameStaffAsEdit = isEdit && String(staffId || "") === String(excludeReservation.staffId || "");
  const editStart = isEdit ? timeToMinutes(excludeReservation.time) : null;
  const editEnd = isEdit
    ? timeToMinutes(excludeReservation.endTime || calculateDefaultEndTime(excludeReservation.time, excludeReservation.service))
    : null;

  // 4) 判定
  const tStart = timeToMinutes(startTime);
  const tEnd   = timeToMinutes(endTime);
  const reasons = [];

  for (let t = tStart; t < tEnd; t += unit) {
    const tStr = minutesToTime(t);
    const row = slots[tStr];

    if (!row || !row[serviceId]) {
      reasons.push({ time: tStr, reason: "※この時間帯の予約はカレンダーに表示されません" });
      continue;
    }

    const cells = row[serviceId];

    // 4-1) 満枠（編集時は自分のぶんだけ1減算）
    let reservedCount = reservedCountMap.get(tStr) || 0;
    if (sameStaffAsEdit && t >= editStart && t < editEnd) {
      reservedCount = Math.max(0, reservedCount - 1);
    }
    if (reservedCount >= capacity) {
      reasons.push({ time: tStr, reason: `この時間帯にはすでに予約が${reservedCount}件入っています（上限${capacity}）` });
      continue;
    }

    // 4-2) 空きセル判定 & 他サービスブロック検出
    let hasGreen = false;                 // その分に“実セル空き”があるか
    let hasOtherServiceBlock = false;     // その分に“他サービスで×”があるか

    for (const cell of cells) {
      const status = cell?.status ?? "";
      const blockedBy = cell?.blockedBy ?? "";
      const name = cell?.name ?? "";

      if (status === "×" && blockedBy === "other-service") {
        hasOtherServiceBlock = true;
      }
      if (status === "🟢" || name === "🟢") {
        hasGreen = true;
      }
    }

    // 編集中の自分の分は“理論上の空き”として扱う（セル表示上は埋まってても選べるべき）
    if (!hasGreen && sameStaffAsEdit && t >= editStart && t < editEnd) {
      hasGreen = true;
    }

    // 4-3) 空きが無ければ理由出し（空きがあるなら注意は出さない）
    if (!hasGreen) {
      if (hasOtherServiceBlock) {
        reasons.push({ time: tStr, reason: "この時間帯には他サービスの予約が入っています" });
      } else {
        reasons.push({ time: tStr, reason: "営業時間外または担当者が不在です" });
      }
    }
  }

  return reasons.length > 0 ? reasons : [];
}

// ======== 追加：永続化キー & ヘルパー ========
const LS_KEYS = {
  pending: "pendingReserveInfo",
  scroll: "scrollMemory",
  scrollPos: "scrollMemoryPosition",
};

function setLastAction(action) {
  try { localStorage.setItem("lastAction", action); } catch (e) {}
}
function consumeLastAction() {
  try {
    const a = localStorage.getItem("lastAction");
    localStorage.removeItem("lastAction");
    return a;
  } catch (e) { return null; }
}

function persistScrollPosToLS() {
  try {
    const wrap = document.querySelector('.table-wrap');
    if (!wrap) return;
    localStorage.setItem(LS_KEYS.scrollPos, JSON.stringify({
      top: wrap.scrollTop,
      left: wrap.scrollLeft
    }));
  } catch (e) {}
}

function restoreScrollPosFromLS() {
  try {
    const wrap = document.querySelector('.table-wrap');
    if (!wrap) return;
    const pos = JSON.parse(localStorage.getItem(LS_KEYS.scrollPos) || "null");
    if (pos && Number.isFinite(pos.top) && Number.isFinite(pos.left)) {
      wrap.scrollTo({ top: pos.top, left: pos.left, behavior: "instant" });
    }
  } catch (e) {}
}

// pendingReserveInfo を LS に保存
function persistPendingInfo() {
  try {
    if (pendingReserveInfo && pendingReserveInfo.date && pendingReserveInfo.time) {
      localStorage.setItem(LS_KEYS.pending, JSON.stringify(pendingReserveInfo));
    }
  } catch (e) {}
}

// pendingReserveInfo を LS から復元
function restorePendingInfo() {
  try {
    const obj = JSON.parse(localStorage.getItem(LS_KEYS.pending) || "null");
    if (obj && obj.date && obj.time) {
      pendingReserveInfo = { ...pendingReserveInfo, ...obj };
      return true;
    }
  } catch (e) {}
  return false;
}

// pending をクリア
function clearPendingInfo() {
  try { localStorage.removeItem(LS_KEYS.pending); } catch (e) {}
}
// 追加：描画完了待ちユーティリティ
function waitFor(cond, timeout = 1000, interval = 50) {
  return new Promise((resolve, reject) => {
    const t0 = performance.now();
    (function tick() {
      if (cond()) return resolve();
      if (performance.now() - t0 > timeout) return reject(new Error('waitFor timeout'));
      setTimeout(tick, interval);
    })();
  });
}

window.addEventListener("pageshow", async () => {
  try {
    // 1) 予約アンカー等を先に復元（メモリへ）
    restorePendingInfo();

    // 2) モード復元（保存があれば必ず合わせる）
    const savedMode = localStorage.getItem("calendarMode");
    if (savedMode === "staff" || savedMode === "service") {
      if (getCurrentMode?.() !== savedMode) {
        currentMode = savedMode;
        setToggleUI(savedMode);
        setupCategorySelect(); 
        initTabs(savedMode);
      } else {
        // 同モードでも initTabs で再描画しておくと安全
        initTabs(savedMode);
      }
    } else {
      initTabs(currentMode);
    }

    // 3) 週キャッシュが生きてるなら即時データ反映
    const startStr = formatDate(currentStartDate);
    const allData = weeklyCache[startStr];
    if (allData) {
      weeklyDataCache = allData;
      setupCategorySelect();
    }

    // 4) 表のDOMが生えたのを待ってから復元実行
    await waitFor(() => document.querySelector('.table-wrap'), 1000);

    // 5) スクロール位置＆ハイライト復元
    restoreScrollPosFromLS();   // 位置
    highlightSavedSlotOnly();   // 直近セルのハイライト＆中央寄せ
  } catch (e) {
    console.debug("pageshow restore skipped:", e);
  }
});

// スリープ復帰やbfcache復帰でも確実に呼ばれるように
window.addEventListener('pageshow', () => {
  // 古いタイマーを全て殺し、世代も進める
  clearIdleTimers();
  idle.gen++;

  // 本当に15分経っているかを時刻で判定
  if (idle.deadline && Date.now() >= idle.deadline) {
    // 期限超過なら即モーダル
    showIdleConfirmModal();
  } else {
    // まだ残りがあるなら残り時間で再アーム
    const remaining = idle.deadline ? Math.max(0, idle.deadline - Date.now()) : IDLE_LIMIT;
    armIdle(remaining);
  }
});


function attachModalInputListeners() {
  const modalEl = document.getElementById("viewReserveModal");
  let excludeReservation = null;
  try {
    excludeReservation = JSON.parse(modalEl?.dataset?.original || "null");
  } catch (_) {
    excludeReservation = null;
  }

  const ids = ["reserve-date","start-time-select","end-time-select","reserve-staff","reserve-service","reserve-designated"];

  const syncPending = () => {
    // 現状値を pendingReserveInfo に反映
    const chk = document.getElementById("reserve-designated");
    if (chk) {
      pendingReserveInfo = {
        ...pendingReserveInfo,
        date: document.getElementById("reserve-date")?.value || pendingReserveInfo.date,
        time: document.getElementById("start-time-select")?.value || pendingReserveInfo.time,
        serviceId: document.getElementById("reserve-service")?.value || pendingReserveInfo.serviceId,
        staffId: document.getElementById("reserve-staff")?.value || pendingReserveInfo.staffId,
        mode: modalEl?.dataset?.mode || pendingReserveInfo.mode,
        original: (() => {
          try { return JSON.parse(modalEl?.dataset?.original || "null") } catch { return pendingReserveInfo.original || null; }
        })(),
      };
    }
    persistPendingInfo();
  };

  ids.forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener("change", () => {
      updateReserveWarning(excludeReservation);
      syncPending();
    });
  });

  // 初回も同期しておく
  syncPending();
}

function updateReserveWarning(excludeReservation = null) {
  const date = document.getElementById("reserve-date")?.value;
  const startTime = document.getElementById("start-time-select")?.value;
  const endTime = document.getElementById("end-time-select")?.value;
  const serviceId = document.getElementById("reserve-service")?.value;
  const staffId = document.getElementById("reserve-staff")?.value;

  if (!date || !startTime || !endTime || !serviceId || !staffId) return;

  const reasons = checkReservationAvailabilityReasons(
    date,
    startTime,
    endTime,
    staffId,
    serviceId,
    excludeReservation
  );

  const warningDiv = document.getElementById("reserve-warning");
  const reserveBtn = document.getElementById("view-reserve-btn");

  // 🔍 予約済が含まれているかチェック（ラベルで判定）
  const hasReserved = reasons.some(r => {
    const label = convertReasonToLabel(r.reason || "");
    return label === "予約済";
  });

  // ⚠️ 文言表示
  if (reasons.length > 0) {
    const unit = weeklyDataCache?.meta?.unitMin || 15;
    warningDiv.classList.remove("d-none");
    warningDiv.innerText = groupReasons(reasons, unit).join("\n");
  } else {
    warningDiv.classList.add("d-none");
    warningDiv.innerText = "";
  }

  // 🚫 ボタンの活性/非活性
  if (reserveBtn) {
    reserveBtn.disabled = hasReserved;
  }
}


function showWarningMessage(msg) {
  const div = document.getElementById("reserve-warning");
  if (!div) return;
  div.classList.remove("d-none");
  div.innerText = msg;
}

function hideWarningMessage() {
  const div = document.getElementById("reserve-warning");
  if (!div) return;
  div.classList.add("d-none");
  div.innerText = "";
}

function formatPhoneNumber(raw) {
  const cleaned = raw.replace(/[^\d]/g, "");
  if (cleaned.length === 11) {
    return cleaned.replace(/(\d{3})(\d{4})(\d{4})/, "$1-$2-$3");
  } else if (cleaned.length === 10) {
    return cleaned.replace(/(\d{2,3})(\d{3,4})(\d{4})/, "$1-$2-$3");
  }
  return raw; // 整形不可ならそのまま
}

function cleanPhone(str) {
  return (str || "").replace(/[^\d]/g, ""); // 数字だけ残す
}

// モーダル内で表示週外の日付を選択した場合のデータ取得関数
async function showReserveModalWithDataCheck(info) {
  const { date } = info;                       // "YYYY-MM-DD"
  const anchorStr = formatDate(toStartOfDayJST(date));

  // ❶ まず直近フェッチ済みの7日窓に入っていれば即利用
  const rng = weeklyDataCache?.meta?.range; // { start, end } をGASが返す
  if (rng && anchorStr >= rng.start && anchorStr <= rng.end) {
    showReserveModal(info);
    return;
  }

  // ❷ 同一キーで既に週キャッシュがあれば利用
  if (weeklyCache[anchorStr]) {
    weeklyDataCache = weeklyCache[anchorStr];
    showReserveModal(info);
    return;
  }

  // ❸ 無ければ取得
  showReservationOverlay("予約データ取得中…");
  google.script.run
    .withSuccessHandler(data => {
      hideReservationOverlay();
      weeklyCache[anchorStr] = data;
      weeklyDataCache = data;
      setupCategorySelect(); 
      showReserveModal(info);
    })
    .withFailureHandler(err => {
      hideReservationOverlay();
      alert("❌ モーダル表示用のデータ取得に失敗しました：" + err.message);
    })
    .getWeeklyMatrixUnified(anchorStr);
}


document.getElementById("view-reserve-btn").addEventListener("click", () => {
  const modalEl = document.getElementById("viewReserveModal");
  const mode = modalEl.dataset.mode || "new";
  const original = JSON.parse(modalEl.dataset.original || "{}");

  const selectedPhone = document.getElementById("customer-select")?.value || "";
  const manualLast = document.getElementById("lastNameInput").value.trim();
  const manualFirst = document.getElementById("firstNameInput").value.trim();
  const manualPhone = document.getElementById("phoneInput").value.trim();
  const emailInputVal = document.getElementById("emailInput")?.value.trim() || "";

  const date = document.getElementById("reserve-date").value;
  const time = document.getElementById("start-time-select").value;
  const endTime = document.getElementById("end-time-select").value;
  const serviceId = document.getElementById("reserve-service").value;
  const staffId = document.getElementById("reserve-staff").value;
  const matchedCustomer = cachedCustomerList?.find(c => cleanPhone(c.phone) === cleanPhone(selectedPhone));
  const isExisting = !!matchedCustomer;

  //スタッフラベル
  let designated;
  const chk = document.getElementById("reserve-designated");
  if (chk) {
      designated = chk.checked;              // ← ユーザーの現在の選択を最優先
  } else if (mode === "edit" && typeof original.designated !== "undefined") {
    designated = !!original.designated;
  } else {
    const selCell = document.querySelector('#table-area td.selected-cell');
    if (selCell && selCell.dataset && selCell.dataset.designated != null) {
      designated = (selCell.dataset.designated === "true");
    } else {
      designated = false;                  // 明示デフォルト
    }
  }

  const staffLabel = designated ? "（指名）" : "";

  lastMatchedCustomer = matchedCustomer;

  const lastName = matchedCustomer?.lastName || manualLast;
  const firstName = matchedCustomer?.firstName || manualFirst;
  const phone = selectedPhone || manualPhone;
  const email = emailInputVal || matchedCustomer?.email || "";
  const cutStyle = matchedCustomer?.cutStyle || "";
  const note = matchedCustomer?.note || "";

  const reservationData = {
    lastName,
    firstName,
    phone,
    email,
    date,
    time,
    endTime,
    service: serviceId,
    staffId
  };

  // ✅ タグチェック
  if (!validateSafeInputs(reservationData)) {
    alert("❌ 入力内容に不正なタグが含まれています。");
    return;
  }

  if (!date || isNaN(new Date(date))) {
    alert("❌ 日付が正しく選択されていません。");
    return;
  }

  const confirmBody = document.getElementById("reserve-confirm-body");
  const confirmWarning = document.getElementById("reserve-confirm-warning");
  const confirmContent = document.getElementById("reserve-confirm-content");

  if (mode === "edit") {
    const confirmWarning = document.getElementById("reserve-confirm-warning");
    confirmWarning.classList.remove("d-none");

    if (window.__hasReserveDiff === false) {
      confirmWarning.innerText = "変更点がありませんが、このまま保存しますか？";
    } else {
      confirmWarning.innerText = "";
      confirmWarning.classList.add("d-none");
    }

    confirmContent.innerHTML = generateConfirmDiffHTML(original, reservationData);
    document.getElementById("confirm-reserve-btn").textContent = "変更";
  }else {
    const service = getServiceNameById(serviceId);
    const staffName = getStaffNameById(staffId) || "－";

    // GASからのデータに designated が含まれている前提
    const staffLabel = designated ? "（指名）" : "";

    const warnings = [];
    if (!lastName) warnings.push("姓が未入力です。");
    if (!firstName) warnings.push("名が未入力です。");
    if (!phone) warnings.push("電話番号が未入力です。");

    if (warnings.length > 0) {
      confirmWarning.className = "text-danger mb-2";
      confirmWarning.innerHTML = `${warnings.join("<br>")}`;
      confirmWarning.classList.remove("d-none");
    } else {
      confirmWarning.classList.add("d-none");
      confirmWarning.innerHTML = "";
    }

    confirmContent.innerHTML = `
      <div><strong>日付：</strong>${formatDateWithWeekday(date)}</div>
      <div><strong>時間：</strong>${time}～${endTime}</div>
      <div><strong>サービス：</strong>${service}</div>
      <div><strong>担当者：</strong>${staffName}${staffLabel}</div>
      <div><strong>予約者名：</strong>${lastName} ${firstName}</div>
      <div><strong>電話番号：</strong>${formatPhoneNumber(phone)}</div>
      <div><strong>メール：</strong>${email || "－"}</div>
      ${cutStyle ? `<div><strong>カットスタイル：</strong>${cutStyle}</div>` : ""}
      ${note ? `<div><strong>備考：</strong>${note}</div>` : ""}
    `;

    document.getElementById("confirm-reserve-btn").textContent = "予約";
  }

  const regBtn = document.getElementById("confirm-reserve-register-btn");
  regBtn.classList.remove("d-none");

  const confirmTitleEl = document.querySelector("#reserveConfirmModal .modal-title");
  if (confirmTitleEl) {
    confirmTitleEl.textContent = mode === "edit"
      ? "この内容で変更してもよろしいですか？"
      : "この内容で予約してもよろしいですか？";
  }

  if (mode === "edit") {
    regBtn.textContent = isExisting
      ? "登録情報を更新して変更"
      : "顧客情報を登録して変更";
  } else {
    regBtn.textContent = isExisting
      ? "登録情報を更新して予約"
      : "顧客情報を登録して予約";
  }

  bootstrap.Modal.getInstance(modalEl).hide();
  setTimeout(() => {
    const confirmModal = new bootstrap.Modal(document.getElementById("reserveConfirmModal"));
    confirmModal.show();
  }, 300);
});


document.getElementById("back-to-form-btn").addEventListener("click", () => {
  const confirmModalEl = document.getElementById("reserveConfirmModal");
  const confirmModalInstance = bootstrap.Modal.getInstance(confirmModalEl);
  confirmModalInstance.hide();

  confirmModalEl.addEventListener("hidden.bs.modal", function handler() {
    confirmModalEl.removeEventListener("hidden.bs.modal", handler);
    const reserveModal = new bootstrap.Modal(document.getElementById("viewReserveModal"));
    reserveModal.show();
  });
});

//予約モーダル
document.getElementById("confirm-reserve-btn").addEventListener("click", () => {
  setLastAction("reserve");
  // ✅ pendingReserveInfoを更新（modeとoriginalは維持される）
  pendingReserveInfo = {
    ...pendingReserveInfo,
    date: document.getElementById("reserve-date")?.value || pendingReserveInfo.date,
    time: document.getElementById("start-time-select")?.value || pendingReserveInfo.time,
    serviceId: document.getElementById("reserve-service")?.value || pendingReserveInfo.serviceId,
    staffId: document.getElementById("reserve-staff")?.value || pendingReserveInfo.staffId
  };

  const reservationData = {
    lastName: document.getElementById("lastNameInput")?.value || "",
    firstName: document.getElementById("firstNameInput")?.value || "",
    phone: document.getElementById("phoneInput")?.value || "",
    email: document.getElementById("emailInput")?.value || "",
    date: pendingReserveInfo.date,
    time: pendingReserveInfo.time,
    endTime: document.getElementById("end-time-select")?.value || "",
    service: pendingReserveInfo.serviceId,
    staffId: pendingReserveInfo.staffId
  };

  // ✅ タグチェックのみ
  if (!validateSafeInputs(reservationData)) {
    alert("❌ 入力内容に不正なタグが含まれています。");
    return;
  }

  // ✅ モーダルを閉じて処理へ進む
  const confirmModal = bootstrap.Modal.getInstance(document.getElementById("reserveConfirmModal"));
  confirmModal?.hide();

  // 予約確定直前にも scrollMemory を確定保存（復帰中断に強くする）
  try {
    const selector = `[data-date="${pendingReserveInfo.date}"][data-time="${pendingReserveInfo.time}"][data-staff-id="${pendingReserveInfo.staffId}"][data-service-id="${pendingReserveInfo.serviceId}"]`;
    const endTimeNow = document.getElementById("end-time-select")?.value || "";
    const lastName = document.getElementById("lastNameInput")?.value?.trim() || "";
    const firstName = document.getElementById("firstNameInput")?.value?.trim() || "";
    const phone = document.getElementById("phoneInput")?.value?.trim() || "";

    localStorage.setItem(LS_KEYS.scroll, JSON.stringify({
      selector,
      meta: {
        date: pendingReserveInfo.date,
        time: pendingReserveInfo.time,
        end: endTimeNow,
        staffId: pendingReserveInfo.staffId,
        serviceId: pendingReserveInfo.serviceId,
        name: `${lastName} ${firstName}`.trim(),
        phone: phone
      }
    }));

    const wrap = document.querySelector('.table-wrap');
    if (wrap) {
      localStorage.setItem(LS_KEYS.scrollPos, JSON.stringify({ top: wrap.scrollTop, left: wrap.scrollLeft }));
    }
  } catch(e) {}


  setTimeout(() => {
    saveReservationFromPending();
  }, 100);
});


// 予約内容確認 → 顧客情報入力モーダルへ
document.getElementById("confirm-reserve-register-btn").addEventListener("click", () => {
  setLastAction("reserve");
  const viewModal = bootstrap.Modal.getOrCreateInstance(document.getElementById("viewReserveModal"));
  const confirmModal = bootstrap.Modal.getOrCreateInstance(document.getElementById("reserveConfirmModal"));
  viewModal.hide();
  confirmModal.hide();

  const last = document.getElementById("lastNameInput")?.value.trim() || "";
  const first = document.getElementById("firstNameInput")?.value.trim() || "";
  const phone = document.getElementById("phoneInput")?.value.trim() || "";

  // 入力をセット
  document.getElementById("regLastName").value = last;
  document.getElementById("regFirstName").value = first;
  document.getElementById("regPhone").value = phone;
  document.getElementById("regLastKana").value = lastMatchedCustomer?.lastKana || "";
  document.getElementById("regFirstKana").value = lastMatchedCustomer?.firstKana || "";
  document.getElementById("regEmail").value =  (document.getElementById("emailInput")?.value.trim() || lastMatchedCustomer?.email || "");
  document.getElementById("regCutStyle").value = lastMatchedCustomer?.cutStyle || "";
  document.getElementById("regNote").value = lastMatchedCustomer?.note || "";

  setTimeout(() => {
    bootstrap.Modal.getOrCreateInstance(document.getElementById("customerRegisterModal")).show();
  }, 300);
});

document.getElementById("skipCustomerRegister").addEventListener("click", () => {
  bootstrap.Modal.getInstance(document.getElementById("customerRegisterModal")).hide();

  setTimeout(() => {
    saveReservationFromPending(); // ← 顧客データなしで予約
  }, 300);
});

document.getElementById("backToConfirmReserve").addEventListener("click", () => {
  bootstrap.Modal.getInstance(document.getElementById("customerRegisterModal")).hide();

  setTimeout(() => {
    bootstrap.Modal.getOrCreateInstance(document.getElementById("viewReserveModal")).show();
  }, 300);
});

function showConflictModal() {
  const modalEl = document.getElementById("conflictModal");
  const modal = new bootstrap.Modal(modalEl, {
    backdrop: 'static', // ← 背景クリック無効
    keyboard: false     // ← Escキー無効
  });

  // 一度だけイベント追加（複数回表示される可能性あるので remove → add）
  modalEl.removeEventListener("hidden.bs.modal", handleConflictClose);
  modalEl.addEventListener("hidden.bs.modal", handleConflictClose);

  modal.show();
}

function handleConflictClose() {
  /*setTimeout(() => {
    goTo("10_availability"); // 🔄 ページをリロード
  }, 300);*/
}
// 計測のON/OFF（必要なら false に）
window.__PERF_SAVE = true;
function tStart(label){ if (window.__PERF_SAVE) console.time(label); }
function tEnd(label){ if (window.__PERF_SAVE) console.timeEnd(label); }
function tLog(label, ...args){ if (window.__PERF_SAVE && console.timeLog) console.timeLog(label, ...args); else if (window.__PERF_SAVE) console.log(label, ...args); }

// 計測トグルは既存のまま利用
function saveReservationFromPending(optionalCustomerData = null) {
  tStart("[save] TOTAL");

  tStart("[save] DOM-read");
  restorePendingInfo();
  const ctx = JSON.parse(JSON.stringify(pendingReserveInfo || {}));
  const isStaffMode = document.getElementById("mode-staff")?.classList.contains("active");

  const lastName  = document.getElementById("lastNameInput")?.value?.trim() || "";
  const firstName = document.getElementById("firstNameInput")?.value?.trim() || "";
  const phoneRaw  = document.getElementById("phoneInput")?.value?.trim() || "";
  const endTime   = document.getElementById("end-time-select")?.value || "";
  const emailInputVal = document.getElementById("emailInput")?.value?.trim() || "";
  const emailFallback  = lastMatchedCustomer?.email || "";

  const cleanPhone = phoneRaw.replace(/[^\d]/g, "");
  const displayName = `${lastName} ${firstName}`.trim();

  // 変更検知（編集時は ctx.original と比較／新規で optionalCustomerData があれば変更扱い）
  const norm = s => String(s || "").replace(/[^\d]/g, "");
  const changedByEdit =
    ctx?.mode === "edit" && ctx?.original ? (
      (ctx.original.lastName || "").trim()   !== lastName ||
      (ctx.original.firstName || "").trim()  !== firstName ||
      norm(ctx.original.phone)               !== cleanPhone
    ) : false;
  const changedByNewData = !!optionalCustomerData; // 新規や顧客更新を伴う保存時のフラグ
  const customerChanged = changedByEdit || changedByNewData;

  const selectorBase =
    `[data-date="${ctx.date}"]` +
    `[data-time="${ctx.time}"]` +
    `[data-service-id="${ctx.serviceId}"]` +
    `[data-staff-id="${ctx.staffId}"]`;
  const selector = `${selectorBase}[data-end="${endTime}"][data-name="${displayName}"][data-phone="${cleanPhone}"]`;
  tEnd("[save] DOM-read");

  tStart("[save] LS/save-scroll");
  localStorage.setItem(LS_KEYS.scroll, JSON.stringify({
    selector,
    meta: { date: ctx.date, time: ctx.time, end: endTime, staffId: ctx.staffId, serviceId: ctx.serviceId, name: displayName, phone: cleanPhone }
  }));
  const wrap = document.querySelector('.table-wrap');
  if (wrap) {
    localStorage.setItem("scrollMemoryPosition", JSON.stringify({ top: wrap.scrollTop, left: wrap.scrollLeft }));
  }
  tEnd("[save] LS/save-scroll");

  tStart("[save] overlay-show");
  showReservationOverlay();
  tEnd("[save] overlay-show");

  const reservationData = {
    lastName, firstName, phone: cleanPhone,email: emailInputVal || emailFallback,
    date: ctx.date, time: ctx.time, endTime,
    service: ctx.serviceId, staffId: ctx.staffId || "",
    designated: document.getElementById("reserve-designated")?.checked || false,
    request: ctx.original?.request || "" 
  };

  // ★ 顧客が変わったときだけ、先にキャッシュ無効化（非同期・待たない）
  if (customerChanged) {
    tStart("[save] RPC invalidateCustomerCache");
    google.script.run
      .withSuccessHandler(() => tEnd("[save] RPC invalidateCustomerCache"))
      .withFailureHandler(() => tEnd("[save] RPC invalidateCustomerCache"))
      .invalidateCustomerCache();
  }

  const save = () => {
    // ===== RPC: saveReservationAdmin =====
    tStart("[save] RPC saveReservationAdmin");
    google.script.run
      .withSuccessHandler(result => {
        tEnd("[save] RPC saveReservationAdmin");

        if (result === "CONFLICT") {
          tLog("[save] RESULT", "CONFLICT");
          hideReservationOverlay();
          tEnd("[save] TOTAL");
          showConflictModal();
          return;
        }

        // 顧客が変わったときだけ再取得（変更なければ呼ばない）
        if (customerChanged) {
          tStart("[save] RPC getCustomerList");
          google.script.run
            .withSuccessHandler(data => {
              tEnd("[save] RPC getCustomerList");
              cachedCustomerList = data || [];
              isCustomerListReady = true;
            })
            .withFailureHandler(err => {
              tEnd("[save] RPC getCustomerList");
              console.warn("[save] getCustomerList failed:", err?.message || err);
            })
            .getCustomerList();
        }

        // ===== RPC: getWeeklyMatrixUnified =====
        const startStr = formatDate(currentStartDate);
        tStart("[save] RPC getWeeklyMatrixUnified");
        google.script.run
          .withSuccessHandler(allData => {
            tEnd("[save] RPC getWeeklyMatrixUnified");

            // ===== フロント反映 =====
            tStart("[save] apply-cache");
            weeklyDataCache = allData;
            weeklyCache[startStr] = allData;
            updateSingleStaffMode(allData);
            tEnd("[save] apply-cache");

            if (isSingleStaffMode) {
              tStart("[save] render:single-staff");
              updateLabel();
              const staff = allData.meta.staffList[0];
              drawTableByStaff(allData.staffView[staff.id], staff.id);
              tEnd("[save] render:single-staff");

              tStart("[save] highlight");
              highlightSavedSlotOnly();
              tEnd("[save] highlight");

              tStart("[save] adjust-width");
              adjustTableMinWidth();
              tEnd("[save] adjust-width");
            } else {
              tStart("[save] tabs/init");
              const targetMode = ctx.viewMode || localStorage.getItem("calendarMode") || currentMode || "service";
              currentMode = targetMode;
              localStorage.setItem("calendarMode", targetMode);
              setToggleUI(targetMode);
              initTabs(targetMode);
              tEnd("[save] tabs/init");

              tStart("[save] tabs/activate");
              const tabsContainer = (targetMode === "staff") ? "#staff-tabs" : "#service-tabs";
              const tabKey = (targetMode === "staff") ? ctx.staffId : ctx.serviceId;
              try { activateTabByDataId(tabsContainer, targetMode, tabKey); } catch (e) { console.warn("activateTabByDataId 失敗:", e); }
              tEnd("[save] tabs/activate");

              tStart("[save] highlight");
              highlightSavedSlotOnly();
              tEnd("[save] highlight");
            }

            tStart("[save] overlay-hide");
            hideReservationOverlay();
            tEnd("[save] overlay-hide");

            clearPendingInfo();
            isLoading = false;

            tEnd("[save] TOTAL");
          })
          .withFailureHandler(err => {
            tEnd("[save] RPC getWeeklyMatrixUnified");
            hideReservationOverlay();
            document.getElementById("table-area").innerHTML =
              `<div class='text-danger'>読み込みエラー: ${err.message}</div>`;
            isLoading = false;
            tEnd("[save] TOTAL");
          })
          .getWeeklyMatrixUnified(startStr);
      })
      .withFailureHandler(err => {
        tEnd("[save] RPC saveReservationAdmin");
        hideReservationOverlay();
        alert("❌ 予約に失敗しました: " + err.message);
        tEnd("[save] TOTAL");
      })
      .saveReservationAdmin(reservationData);
  };

  if (ctx.mode === "edit" && ctx.original) {
    const editToken =
      (window.crypto && crypto.randomUUID) ? crypto.randomUUID()
        : (Date.now().toString(36) + Math.random().toString(36).slice(2));

    tStart("[save] RPC deleteReservation");
    google.script.run
      .withSuccessHandler(() => {
        tEnd("[save] RPC deleteReservation");
        // ← ここでフラグを付与して既存 save() を再利用
        reservationData._forUpdate = true;
        reservationData._editToken = editToken;
        save(); // 既存の成功/失敗ハンドラ・再描画・オーバーレイ解除をそのまま使う
      })
      .withFailureHandler(err => {
        tEnd("[save] RPC deleteReservation");
        hideReservationOverlay();
        alert("❌ 変更前の予約削除に失敗しました: " + err.message);
        tEnd("[save] TOTAL");
      })
      .deleteReservation({ ...ctx.original, _forUpdate: true, _editToken: editToken });  // ← ... に修正
  } else {
    save();
  }
}


document.getElementById("submitCustomerRegister").addEventListener("click", () => {
  const data = {
    id: lastMatchedCustomer?.id || null,
    lastName: document.getElementById("regLastName").value.trim(),
    firstName: document.getElementById("regFirstName").value.trim(),
    lastKana: document.getElementById("regLastKana").value.trim(),
    firstKana: document.getElementById("regFirstKana").value.trim(),
    phone: document.getElementById("regPhone").value.trim(),
    email: document.getElementById("regEmail").value.trim(),
    cutStyle: document.getElementById("regCutStyle").value.trim(),
    note: document.getElementById("regNote").value.trim()
  };

  if (!validateSafeInputs(data)) {
    alert("❌ 入力内容に不正なタグが含まれています。");
    return;
  }

  if (!data.lastName || !data.firstName || !data.phone) {
    alert("姓・名・電話番号は必須です！");
    return;
  }

  //document.getElementById("submitCustomerRegister").disabled = true;

  // ✅ モーダル閉じて、スピナー表示（顧客登録中）
  bootstrap.Modal.getInstance(document.getElementById("customerRegisterModal")).hide();
  showReservationOverlay("顧客登録中...");

  // ✅ 顧客登録 → 登録後に予約処理
  google.script.run.withSuccessHandler(() => {
    // ✅ 顧客リストを更新してから予約処理へ
    google.script.run.withSuccessHandler(data => {
      cachedCustomerList = data || [];
      isCustomerListReady = true;

      const phone = document.getElementById("regPhone").value.trim();
      lastMatchedCustomer = cachedCustomerList.find(c => cleanPhone(c.phone) === cleanPhone(phone));

      populateCustomerSelect();

      if (lastMatchedCustomer) {
        const select = document.getElementById("customer-select");
        const phone = cleanPhone(lastMatchedCustomer.phone);
        select.value = phone;
        select.dispatchEvent(new Event("change"));
      }

      showReservationOverlay("予約処理中...");
      saveReservationFromPending(data);

    }).getCustomerList();

  }).withFailureHandler(err => {
    hideReservationOverlay();
    alert("❌ 顧客登録に失敗しました: " + err.message);
  }).saveCustomer(data);

});

//変更ボタンがおされたら、予約変更モーダル表示
document.getElementById("edit-reserve-btn").addEventListener("click", () => {
  const modal = bootstrap.Modal.getInstance(document.getElementById("viewConfirmModal"));
  modal.hide();

  // 元予約データ（pendingReserveInfo）を使って編集モードでモーダル再表示
  setTimeout(() => {
    showReserveModal({
      date: pendingReserveInfo.date,
      time: pendingReserveInfo.time,
      service: getServiceNameById(pendingReserveInfo.service),
      staff: getStaffNameById(pendingReserveInfo.staffId),
      serviceId: pendingReserveInfo.service,
      staffId: pendingReserveInfo.staffId,
      mode: "edit",
      original: {
        ...pendingReserveInfo,
        designated: pendingReserveInfo.designated
      }
    });
  }, 300);
});


// 🟥 削除ボタンが押されたら、確認モーダル表示
  document.getElementById("delete-btn")?.addEventListener("click", () => {
    const modal = bootstrap.Modal.getInstance(document.getElementById("viewConfirmModal"));
    modal?.hide();

    const confirmModal = new bootstrap.Modal(document.getElementById("confirmDeleteModal"));
    confirmModal.show();
  });

  // ❌ キャンセル → 元の確認モーダルに戻す
  document.getElementById("cancel-delete-btn")?.addEventListener("click", () => {
    const deleteModal = bootstrap.Modal.getInstance(document.getElementById("confirmDeleteModal"));
    deleteModal?.hide();

    const confirmModal = new bootstrap.Modal(document.getElementById("viewConfirmModal"));
    confirmModal.show();
  });

  // ✅ 本当に削除 → GAS呼び出し
  document.getElementById("confirm-delete-btn")?.addEventListener("click", () => {
    const deleteModal = bootstrap.Modal.getInstance(document.getElementById("confirmDeleteModal"));
    deleteModal?.hide();

    // 先頭スロットだけを狙う最小セレクタ（削除後も一致する）
    const svcId =
      pendingReserveInfo.serviceId
      || pendingReserveInfo.service
      || document.querySelector(
          `[data-date="${pendingReserveInfo.date}"][data-time="${pendingReserveInfo.time}"][data-staff-id="${pendingReserveInfo.staffId}"][data-service-id]`
        )?.dataset?.serviceId
      || ""; // 取れなければ空（属性を付けない）

    let selector =
      `[data-date="${pendingReserveInfo.date}"]` +
      `[data-time="${pendingReserveInfo.time}"]` +
      `[data-staff-id="${pendingReserveInfo.staffId}"]`;
    if (svcId) selector += `[data-service-id="${svcId}"]`;

    const lastName = document.getElementById("lastNameInput")?.value?.trim() || "";
    const firstName = document.getElementById("firstNameInput")?.value?.trim() || "";
    const phone = document.getElementById("phoneInput")?.value?.trim() || "";
    const endTime = document.getElementById("end-time-select")?.value || "";

    localStorage.setItem(LS_KEYS.scroll, JSON.stringify({
      selector,
      meta: {
        date: pendingReserveInfo.date,
        time: pendingReserveInfo.time,
        end: endTime,                 // ← data-end との突き合わせに使う
        staffId: pendingReserveInfo.staffId,
        serviceId: svcId,
        name: `${lastName} ${firstName}`.trim(), // ← data-name と比較
        phone: phone                               // ← data-phone と比較（どちらか一致でOK）
      }
    }));


    const wrap = document.querySelector('.table-wrap');
    if (wrap) {
      localStorage.setItem(LS_KEYS.scrollPos, JSON.stringify({
        top: wrap.scrollTop,
        left: wrap.scrollLeft
      }));
    }
    
    try {
      if (typeof setLastAction === "function") setLastAction("delete");
      else localStorage.setItem(LS_KEYS.lastAction, "delete");
    } catch {}


    showReservationOverlay("削除中…");

    google.script.run
      .withSuccessHandler(() => {
        const startStr = formatDate(currentStartDate);
        google.script.run
          .withSuccessHandler(allData => {
            weeklyDataCache = allData;
            weeklyCache[startStr] = allData;
            initTabs(currentMode);
            hideReservationOverlay();
            highlightSavedSlotOnly();
          })
          .withFailureHandler(err => {
            hideReservationOverlay();
            alert("❌ 表再取得失敗：" + err.message);
          })
          .getWeeklyMatrixUnified(startStr);
      })
      .withFailureHandler(err => {
        hideReservationOverlay();
        alert("❌ 削除失敗：" + err.message);
      })
      .deleteReservation(pendingReserveInfo);
  });

// OK → 処理へ進む
document.getElementById("input-check-ok-btn").addEventListener("click", () => {
  const confirmModal = bootstrap.Modal.getInstance(document.getElementById("inputCheckModal"));
  if (confirmModal) confirmModal.hide();

  if (typeof window._onMissingConfirmOk === "function") {
    window._onMissingConfirmOk();
  }
});

// キャンセル → 元のモーダルに戻す
document.querySelector("#inputCheckModal .btn-secondary").addEventListener("click", () => {
  if (modalToRestore) {
    setTimeout(() => {
      const restoreModal = new bootstrap.Modal(document.getElementById(modalToRestore));
      restoreModal.show();
      modalToRestore = null;
    }, 300);
  }
});

function generateConfirmDiffHTML(original, updated) {
  const fields = [
    { key: "date", label: "日付", format: val => formatDateWithWeekday(val) },
    { key: "time", label: "開始時間" },
    { key: "endTime", label: "終了時間" },
    { key: "service", label: "サービス", format: getServiceNameById },
    { key: "staffId", label: "担当者", format: getStaffNameById },
    { key: "lastName", label: "姓" },
    { key: "firstName", label: "名" },
    {
      key: "phone",
      label: "電話番号",
      format: formatPhoneNumber,
      normalize: val => val.replace(/[^\d]/g, "")  // ← 比較用に整形
    },
    { key: "email",   label: "メールアドレス",
      normalize: v => String(v||"").trim().toLowerCase() }
  ];

  const lines = fields.map(({ key, label, format, normalize }) => {
    const rawOld = original?.[key] ?? "";
    const rawNew = updated?.[key] ?? "";

    const oldVal = normalize ? normalize(rawOld) : rawOld;
    const newVal = normalize ? normalize(rawNew) : rawNew;

    const formatVal = format || (v => v || "－");

    if (oldVal !== newVal) {
      return `<div><strong>${label}：</strong><span class="text-danger fw-bold">${formatVal(rawOld)} → ${formatVal(rawNew)}</span></div>`;
    } else {
      return `<div><strong>${label}：</strong>${formatVal(rawNew)}</div>`;
    }
  });

  return lines.join("");
}

function findMaxAvailableEndTime(startTime, date, staffId, serviceId, excludeReservation) {
  const unit = weeklyDataCache?.meta?.unitMin || 15;
  const candidates = getEndTimeCandidates(startTime, date, staffId, serviceId);
  const startMin = timeToMinutes(startTime);

  let lastValid = null;

  for (const endTime of candidates) {
    const endMin = timeToMinutes(endTime);
    let hasConflict = false;

    for (let t = startMin; t < endMin; t += unit) {
      const tStr = minutesToTime(t);
      const reasons = checkReservationAvailabilityReasons(
        date,
        tStr,
        minutesToTime(t + unit),
        staffId,
        serviceId,
        excludeReservation
      );

      const label = reasons.length > 0 ? convertReasonToLabel(reasons[0].reason || "") : "";
      
      if (["予約済", "予約不可"].includes(label)) {
        hasConflict = true;
        break;
      }
    }

    if (hasConflict) break;
    lastValid = endTime;
  }
  return lastValid;
}

function enableSaveIfChanged() {
  const modal = document.getElementById("viewReserveModal");
  const original = JSON.parse(modal.dataset.original || "{}");

  const date = document.getElementById("reserve-date").value;
  const time = document.getElementById("start-time-select").value;
  const endTime = document.getElementById("end-time-select").value;
  const service = document.getElementById("reserve-service").value;
  const staff = document.getElementById("reserve-staff").value;
  const last = document.getElementById("lastNameInput").value;
  const first = document.getElementById("firstNameInput").value;
  const phone = document.getElementById("phoneInput").value;
  const email = document.getElementById("emailInput").value;

  const current = {
    date,
    time,
    endTime,
    service,
    staffId: staff,
    lastName: last,
    firstName: first,
    phone,
    email,
  };

  const normalize = val => val?.toString().trim().replace(/[^\d]/g, "");
  const hasDiff = Object.keys(current).some(k => {
    const oldVal = normalize(original?.[k] || "");
    const newVal = normalize(current[k] || "");
    return oldVal !== newVal;
  });

  window.__hasReserveDiff = hasDiff;

  //変更ない場合の「次へ」ボタン非活性処理
  //const btn = document.getElementById("view-reserve-btn");
  //if (btn) btn.disabled = !hasDiff;
}
 
function showModalInlineSpinner(on) {
  const head = document.querySelector('#viewReserveModal .modal-title');
  if (!head) return;
  if (on) {
    if (!head.querySelector('.mini-spinner')) {
      head.insertAdjacentHTML('beforeend', ' <span class="mini-spinner spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>');
    }
  } else {
    head.querySelector('.mini-spinner')?.remove();
  }
}

function getActiveMode() {
  if (document.querySelector('#mode-staff.active'))   return 'staff';
  if (document.querySelector('#mode-service.active')) return 'service';
  return window.currentMode || 'service';
}

// ✅ 週データのロード（キャッシュ優先）＋ カレンダー表示をその週へ
async function ensureWeekAndApply(dateStr) {
  const weekStartStr = formatDate(toStartOfDayJST(new Date(dateStr)));

  if (!weeklyCache[weekStartStr]) {
    showModalInlineSpinner(true);
    try {
      const data = await new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .getWeeklyMatrixUnified(weekStartStr);
      });
      weeklyCache[weekStartStr] = data;
    } finally {
      showModalInlineSpinner(false);
    }
  }
  weeklyDataCache = weeklyCache[weekStartStr];

  //今のモードを固定して使う
  const mode = getActiveMode();
  window.currentMode = mode; // 一応グローバルも合わせる

  try {
    if (typeof currentStartDate !== "undefined") {
      currentStartDate = toStartOfDayJST(new Date(dateStr));
    }
    if (typeof initTabs === "function")  initTabs(mode);
    if (typeof updateLabel === "function") updateLabel();

    // モードに合わせて描画
    if (mode === "staff" && typeof drawTableByStaff === "function") {
      const staffId = localStorage.getItem("defaultStaffId")|| weeklyDataCache.meta.staffList[0]?.id;
      drawTableByStaff(weeklyDataCache.staffView[staffId], staffId);
    } else if (typeof drawTable === "function") {
      drawTable(weeklyDataCache, "");
    }
  } catch (_) {}
}

function focusSelectedCell({ date, time, serviceId, staffId }) {
  if (!date || !time) return;
  document.querySelectorAll('.selected-cell').forEach(el => el.classList.remove('selected-cell'));

  const candidates = [
    // ✅ 追加：サービス×スタッフで列を特定（最優先）
    `[data-date="${date}"][data-time="${time}"][data-service-id="${serviceId}"][data-staff-id="${staffId}"].selectable-cell`,
    // 次点：スタッフだけ
    `[data-date="${date}"][data-time="${time}"][data-staff-id="${staffId}"].selectable-cell`,
    // 次点：サービスだけ
    `[data-date="${date}"][data-time="${time}"][data-service-id="${serviceId}"].selectable-cell`,
    // 最後：時間だけ
    `[data-date="${date}"][data-time="${time}"].selectable-cell`
  ];

  let target = null;
  for (const sel of candidates) {
    const list = [...document.querySelectorAll(sel)];
    if (list.length === 0) continue;
    target = list.find(el =>
      el.dataset.status === 'available' ||
      el.textContent.trim() === '🟢' ||
      el.classList.contains('available')
    ) || list[0];
    if (target) break;
  }

  if (!target) return;
  target.classList.add('selected-cell');
  target.scrollIntoView({ block: "center", inline: "center", behavior: "smooth" });
}

// 満枠だけを判定
// ✅ 今のモーダル選択が「予約済み（自分含む）」かを判定（＝裏UIを止める条件だけ拾う）
function isReservedSelectionNow() {
  const d  = document.getElementById("reserve-date")?.value || "";
  const st = document.getElementById("start-time-select")?.value || "";
  const sv = document.getElementById("reserve-service")?.value || "";
  const sf = document.getElementById("reserve-staff")?.value || "";
  if (!d || !st || !sv || !sf) return false;

  const endSel = document.getElementById("end-time-select")?.value || "";
  const et = endSel || calculateDefaultEndTime(st, sv);

  // 自分もカウントするため excludeReservation は渡さない
  const reasons = checkReservationAvailabilityReasons(d, st, et, sf, sv, /*excludeReservation=*/null) || [];

  // ⛔ 裏UIを止めるのは「満枠系」だけ。
  //    下2つは対象外（ハイライトOK）なので除外:
  //      ・この時間帯には他サービスの予約が入っています
  //      ・営業時間外または担当者が不在です
  const isFullReason = (txt) =>
    typeof txt === "string" &&
    /予約が\d+件.*上限\d+/.test(txt);                  // 正規表現（例: 予約が3件…上限2）

  // 互換: 文言が微妙に変わっても拾えるように保険
  const isFullReasonFallback = (txt) =>
    typeof txt === "string" &&
    txt.includes("すでに予約が") && txt.includes("上限");

  const isOtherService = (txt) => typeof txt === "string" && txt.includes("他サービスの予約");
  const isClosedOrAbsent = (txt) => typeof txt === "string" && txt.includes("営業時間外または担当者が不在");

  // 1つでも「満枠系」理由があれば、裏UI操作は抑止
  return reasons.some(r => {
    const t = r?.reason;
    if (isOtherService(t) || isClosedOrAbsent(t)) return false; // ← 除外
    return isFullReason(t) || isFullReasonFallback(t);          // ← 満枠だけ true
  });
}



function showReserveConfirmModal() {
  const modal = new bootstrap.Modal(document.getElementById("reserveConfirmModal"));
  modal.show();
}

function showReserveModal({ date, time, service, staff, serviceId, staffId, warning = "", mode = "new", original = null }) {
  const { start: minDate, end: maxDate } = getCurrentWeekRange();
  const excludeReservation = (mode === "edit" ? original : null); 

  // 🔽 タイトル切り替え処理
  const modalTitle = document.querySelector("#viewReserveModal .modal-title");
  if (modalTitle) {
    modalTitle.textContent = (mode === "edit") ? "予約変更" : "予約入力";
  }

  if (!warning) {
    const unit = weeklyDataCache?.meta?.unitMin || 15;
    const reasons = checkReservationAvailabilityReasons(
      date,
      time,
      calculateDefaultEndTime(time, serviceId),
      staffId,
      serviceId,
      excludeReservation
    );
    if (reasons.length > 0) {
      warning = groupReasons(reasons, unit).join("\n");
    }
  }

  const desiredEndTime = calculateDefaultEndTime(time, serviceId);
  const maxEndTime = findMaxAvailableEndTime(time, date, staffId, serviceId, excludeReservation);

  // 🔁 desiredEndTime が maxEndTime よりも後ろなら、そこまでは取れないということ
  let selectedEndTime = (!maxEndTime || timeToMinutes(desiredEndTime) <= timeToMinutes(maxEndTime))
    ? desiredEndTime
    : maxEndTime;

  const body = document.getElementById("reserve-modal-body");

  body.innerHTML = `
    <div id="reserve-warning" class="text-danger mb-2 ${warning ? "" : "d-none"}">
      ${warning ? `${warning.replace(/\n/g, "<br>")}` : ""}
    </div>
    <div class="mb-1">
      <label class="form-label fw-bold">日付</label>
      <input type="date" class="form-control form-control-sm"
            id="reserve-date"
            value="${date}"
      </div>
    <div class="mb-1">
      <label class="form-label fw-bold d-block">時間</label>
      <div class="d-flex align-items-center">
        <select class="form-select form-select-sm me-1" id="start-time-select" style="width:auto;">
          ${generateStartTimeOptionsHTML(date, time, staffId, serviceId, excludeReservation)} 
        </select>
        <span class="me-1">～</span>
        <select class="form-select form-select-sm" id="end-time-select" style="width:auto;">
          ${generateEndTimeOptionsHTML(time, date, selectedEndTime, staffId, serviceId, excludeReservation)} 
        </select>
      </div>
    </div>
    <div class="mb-1">
      <label class="form-label fw-bold">サービス</label>
      <select class="form-select form-select-sm" id="reserve-service">
        ${generateServiceOptionsHTML(serviceId)}
      </select>
    </div>
    <div class="mb-1">
      <label class="form-label fw-bold">担当者</label>
      <select class="form-select form-select-sm" id="reserve-staff">
        ${generateStaffOptionsHTML(staffId, serviceId)}
      </select>
    </div>
    <div class="form-check mb-1">
      <input class="form-check-input" type="checkbox" id="reserve-designated">
      <label class="form-check-label" for="reserve-designated">担当者指名の場合はチェック</label>
    </div>
    <div class="mb-1">
      <label for="customer-select" class="form-label fw-bold">登録済み顧客</label>
      <select id="customer-select" class="form-select form-select-sm"></select>
    </div>
    <div class="row mb-1">
      <div class="col-6">
        <label class="form-label fw-bold">姓</label>
        <input type="text" class="form-control form-control-sm" id="lastNameInput" />
      </div>
      <div class="col-6">
        <label class="form-label fw-bold">名</label>
        <input type="text" class="form-control form-control-sm" id="firstNameInput" />
      </div>
    </div>
    <div class="mb-1">
      <label class="form-label fw-bold">電話番号</label>
      <input type="tel" class="form-control form-control-sm" id="phoneInput" />
    </div>
    <div class="mb-1">
      <label>メールアドレス</label>
      <input type="email" id="emailInput" class="form-control" placeholder="example@mail.com" autocomplete="email">
    </div>
  `;

  {
    const chk = document.getElementById("reserve-designated");
    if (mode === "edit" && original && typeof original.designated !== "undefined") {
      chk.checked = !!original.designated;
    } else {
      // 新規の場合や original に情報がない場合 → 選択セルの dataset から拾う
      const selCell = document.querySelector('#table-area td.selected-cell');
      if (selCell && selCell.dataset.designated) {
        chk.checked = (selCell.dataset.designated === "true");
      }
    }
  }

  // 顧客リスト表示
  populateCustomerSelect();

  // 2. 選択を反映（遅延または render を Promise 化する）
  setTimeout(() => {
    const custSelect = document.getElementById("customer-select");

    if (mode === "edit" && original?.phone) {
      const phoneRaw = original.phone;
      const phone = phoneRaw.replace(/-/g, "");

      const found = Array.from(custSelect.options).some(opt => opt.value === phone);

      if (custSelect && found) {
        custSelect.value = phone;
        custSelect.dispatchEvent(new Event("change"));
      } else {
        document.getElementById("lastNameInput").value = original.lastName || "";
        document.getElementById("firstNameInput").value = original.firstName || "";
        document.getElementById("phoneInput").value = original.phone || "";
        document.getElementById("emailInput").value = original.email || "";
        document.getElementById("reserve-designated").checked = !!original.designated;
      }
    }
  }, 50);

  // ✅ 編集情報を保持
  const modalEl = document.getElementById("viewReserveModal");
  modalEl.dataset.mode = mode;
  modalEl.dataset.original = original ? JSON.stringify(original) : "";

  pendingReserveInfo = {
    date,
    time,
    serviceId,
    staffId,
    mode,
    original,
  };

  persistPendingInfo();

  // ✅ ボタン文言変更
  const saveBtn = document.getElementById("view-reserve-btn");
  if (saveBtn) {
    saveBtn.textContent = (mode === "edit") ? "次へ" : "次へ";
    saveBtn.disabled = (mode === "edit");
  }

  if (mode === "edit") {
    saveBtn.disabled = true;  // ← 初期は非活性
  }

  // ✅ 編集モード時の補完処理
  if (mode === "edit" && original) {
    document.getElementById("reserve-date").value = original.date || date;
    document.getElementById("start-time-select").value = original.time || time;
    document.getElementById("end-time-select").value = original.endTime || desiredEndTime;
    document.getElementById("reserve-service").value = original.service || serviceId;
    document.getElementById("reserve-staff").value = original.staffId || staffId;
    document.getElementById("lastNameInput").value = original.lastName || "";
    document.getElementById("firstNameInput").value = original.firstName || "";
    document.getElementById("phoneInput").value = original.phone || "";
    document.getElementById("emailInput").value = original.email || "";
  }

  // 日付変更時の週またぎチェック
  document.getElementById("reserve-date")?.addEventListener("change", async (e) => {
    const newDate = e.target.value;

    await ensureWeekAndApply(newDate); // 裏だけ更新（モード維持）

    updateTimeOptions((mode === "edit" ? original : null));
    updateReserveWarning((mode === "edit" ? original : null));
    
    if (isReservedSelectionNow()) return;

    // 次フレームで中央スクロール＆ハイライト
    requestAnimationFrame(() => {
      focusSelectedCell({
        date: newDate,
        time: document.getElementById("start-time-select")?.value || "",
        serviceId: document.getElementById("reserve-service")?.value || "",
        staffId: document.getElementById("reserve-staff")?.value || ""
      });
    });
  });

  // 終了時間の候補更新
  document.getElementById("start-time-select")?.addEventListener("change", () => {
    const startTime = document.getElementById("start-time-select").value;
    const date = document.getElementById("reserve-date").value;
    const staffId = document.getElementById("reserve-staff").value;
    const serviceId = document.getElementById("reserve-service").value;
    const endSelect = document.getElementById("end-time-select");

    const modalEl = document.getElementById("viewReserveModal");
    let excludeReservation = null;
    let mode = "new";
    try {
      excludeReservation = JSON.parse(modalEl?.dataset?.original || "null");
      mode = modalEl?.dataset?.mode || "new";
    } catch (_) {}

    let currentEndTime = endSelect.value || "";
    let selectedEndTime = "";

    if (mode === "edit" && excludeReservation) {
      const adjustedEnd = getAdjustedEndTimeForEditMode(
        startTime,
        currentEndTime,
        date,
        staffId,
        serviceId,
        excludeReservation
      );
      selectedEndTime = getAdjustedEndTimeIfInvalid(
        startTime,
        adjustedEnd,
        date,
        staffId,
        serviceId,
        excludeReservation
      );
    } else {
      const desiredEndTime = calculateDefaultEndTime(startTime, serviceId);
      const maxEndTime = findMaxAvailableEndTime(
        startTime,
        date,
        staffId,
        serviceId,
        excludeReservation
      );
      selectedEndTime = (!maxEndTime || timeToMinutes(desiredEndTime) <= timeToMinutes(maxEndTime))
        ? desiredEndTime
        : maxEndTime;
    }

    // ✅ 常に終了時間の候補を更新する ← ここが大事！
    endSelect.innerHTML = generateEndTimeOptionsHTML(
      startTime,
      date,
      selectedEndTime,
      staffId,
      serviceId,
      excludeReservation
    );

    // ✅ value を設定（なければ先頭）
    const endValues = [...endSelect.options].map(opt => opt.value);
    endSelect.value = endValues.includes(selectedEndTime) ? selectedEndTime : endValues[0] || "";
    requestAnimationFrame(() => {
      focusSelectedCell({
        date,
        time: startTime,
        serviceId,
        staffId
      });
    });
  });

  // サービス変更時（タブ切り替えも含む）
  document.getElementById("reserve-service")?.addEventListener("change", () => {
    const newServiceId = document.getElementById("reserve-service").value;
    const staffSelect = document.getElementById("reserve-staff");

    staffSelect.innerHTML = generateStaffOptionsHTML(null, newServiceId);
    staffSelect.selectedIndex = 0;
    const newStaffId = staffSelect.options[0]?.value || "";

    updateTimeOptions(original);
    updateReserveWarning((mode === "edit" ? original : null));

    if (isReservedSelectionNow()) return;

    const inServiceMode = document.querySelector("#mode-service.active");
    if (inServiceMode) {
      activateTabByDataId("#service-tabs", "service", newServiceId);
    }
    const inStaffMode = document.querySelector("#mode-staff.active");
    if (inStaffMode && newStaffId) {
      activateTabByDataId("#service-tabs", "staff", newStaffId);
    }

    focusSelectedCell({
      date: document.getElementById("reserve-date")?.value || "",
      time: document.getElementById("start-time-select")?.value || "",
      serviceId: newServiceId,
      staffId: newStaffId
    });
  });

  // スタッフ変更時
  document.getElementById("reserve-staff")?.addEventListener("change", () => {
    const newStaffId = document.getElementById("reserve-staff").value;

    updateTimeOptions(original);
    updateReserveWarning((mode === "edit" ? original : null));

    if (isReservedSelectionNow()) return;

    const inServiceMode = document.querySelector("#mode-service.active");
    if (inServiceMode && newStaffId) {
      // サービス表示中でも、サービスタブ内の「スタッフ列」を切替
      activateTabByDataId("#service-tabs", "staff", newStaffId);
    }

    const inStaffMode = document.querySelector("#mode-staff.active");
    if (inStaffMode && newStaffId) {
      activateTabByDataId("#service-tabs", "staff", newStaffId);
    }

    // タブ切替直後は描画完了を1フレーム待ってからフォーカス
    requestAnimationFrame(() => {
      focusSelectedCell({
        date: document.getElementById("reserve-date")?.value || "",
        time: document.getElementById("start-time-select")?.value || "",
        serviceId: document.getElementById("reserve-service")?.value || "",
        staffId: newStaffId
      });
    });
  });


  const modalInstance = bootstrap.Modal.getOrCreateInstance(modalEl);
  modalInstance.show();
  attachModalInputListeners();
  updateReserveWarning((mode === "edit" ? original : null));

  if (mode === "edit") {
    const ids = [
      "reserve-date", "start-time-select", "end-time-select",
      "reserve-service", "reserve-staff",
      "lastNameInput", "firstNameInput", "phoneInput","emailInput",
      "customer-select"
    ];
    for (const id of ids) {
      document.getElementById(id)?.addEventListener("input", enableSaveIfChanged);
      document.getElementById(id)?.addEventListener("change", enableSaveIfChanged);
    }
  }

  setTimeout(() => {
    setupModalScrollListeners();
    scrollToSelectedSlotInModal();  // 最初に一回スクロール
  }, 300);
}


// ⏱ 開始時間 + 所要時間 → 初期の終了時間を返す
function calculateDefaultEndTime(startTime, serviceId) {
  const serviceList = weeklyDataCache?.meta?.serviceList || [];
  const svc = serviceList.find(s => s.id === serviceId);
  if (!svc) return "";

  const duration = Number(svc.duration) || 0; // 単位は「分」
  const startMin = timeToMinutes(startTime);
  const endMin = startMin + duration;

  return minutesToTime(endMin);
}

if (prefillDate) {
  const targetDate = new Date(prefillDate);
  currentStartDate = toStartOfDayJST(targetDate);
}

//サニタイズ
function escapeHtml(str) {
  if (str == null) return "";
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}


window.addEventListener("DOMContentLoaded", () => {
  console.log("[CHILD] DOMContentLoaded → child-ready を親へ送信");
  try {
    window.top.postMessage(
      { type: "misemaru:child-ready", origin: location.origin },
      "*" // 親側で必ず event.origin を検証するので安全
    );
  } catch (err) {
    console.error("[CHILD] child-ready 送信失敗:", err);
  }

  const staffBtn = document.getElementById("mode-staff");
  const serviceBtn = document.getElementById("mode-service");

  const savedMode = localStorage.getItem("calendarMode");
  if (savedMode === "staff" || savedMode === "service") {
    currentMode = savedMode;
  } else if (staffBtn?.classList.contains("active")) {
    currentMode = "staff";
  } else {
    currentMode = "service";
  }

  setToggleUI(currentMode);
  initTabs(currentMode);

  // ✅ idle タイマー初期化
  resetIdleTimer();

  // ✅ ユーザー操作でタイマーリセット
  ['click','keydown','touchstart','scroll','mousemove'].forEach(ev => {
  window.addEventListener(ev, () => {
    // モーダル表示中はリセットしない（誤タップで閉じないように）
    const modalShown = document.getElementById('idleModal')?.classList.contains('show');
    if (!modalShown) resetIdleTimer();
  }, { passive: true });
});

  // ✅ スマホ対応：復帰時に idle チェック
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
      // 復帰時は pageshow と同じ判定でOK（保険）
      if (idle.deadline && Date.now() >= idle.deadline) {
        clearIdleTimers();
        idle.gen++;
        showIdleConfirmModal();
      } else {
        const remaining = idle.deadline ? Math.max(0, idle.deadline - Date.now()) : IDLE_LIMIT;
        armIdle(remaining);
      }
    } else {
      // 非表示になる瞬間では特別なことは不要（締切は deadline で保持）
      // タイマーはOS側で止まっても、復帰時にdeadline基準で再評価する
    }
  });

  const startStr = formatDate(currentStartDate);
  showLoadingSpinner();

  google.script.run.withSuccessHandler(data => {
    cachedCustomerList = data || [];
    isCustomerListReady = true;
  }).getCustomerList();

  // ✅ イベントリスナーは DOM 読み込み後に安全に登録
  const tableArea = document.getElementById("table-area");
  if (tableArea) {
    tableArea.addEventListener("click", function (e) {
    const cell = e.target.closest("td");
    if (!cell || !cell.classList.contains("selectable-cell")) return;

    document.getElementById("page-end")?.scrollIntoView({ behavior: "smooth" });

    const content = cell.textContent.trim();

    const date = cell.dataset.date;
    const time = cell.dataset.time;
    let staffId = cell.dataset.staffId || "";
    let serviceId = cell.dataset.serviceId || "";

    const siblings = [...tableArea.querySelectorAll(`td[data-date="${date}"][data-time="${time}"][data-staff-id="${staffId}"][data-service-id="${serviceId}"]`)];
    const colIndex = siblings.indexOf(cell);  // ← 現在の列を特定

    pendingReserveInfo = { date, time, staffId, serviceId, colIndex, mode: currentMode };
    persistPendingInfo?.(); 

    if (currentMode === "service") {
      const activeTab = document.querySelector("#service-tabs .active");
      serviceId = activeTab?.dataset.serviceId || serviceId;
    }
    if (currentMode === "staff") {
      const activeTab = document.querySelector("#service-tabs .active");
      staffId = activeTab?.dataset.staffId || staffId;
    }

    pendingReserveInfo = { date, time, staffId, serviceId };

    const name = cell.dataset.name || "";
    const start = cell.dataset.start || time;
    const end = cell.dataset.end || "";
    const phone = cell.dataset.phone || "";
    const email = cell.dataset.email || "";
    const cutStyle = cell.dataset.cutstyle || "";
    const note = cell.dataset.note || "";
    const request = cell.dataset.request || "";


    const staff = getStaffNameById(staffId);
    const service = getServiceNameById(serviceId);
    if (["〇", "－", "×"].includes(content)) {
      if (!isCustomerListReady) {
        alert("⚠️ 顧客情報を読み込み中です。もう一度お試しください。");
        return;
      }

      showReserveModalWithDataCheck({
        date,
        time,
        staff,
        service,
        serviceId,
        staffId
      });
    }else {
      const body = document.getElementById("confirm-modal-body");

      const [lastName, firstName] = name.split(" ");
      const designatedAttr = cell.dataset.designated;
      const isDesignated = (designatedAttr === "true");
      pendingReserveInfo = {
        date,
        time: start,
        endTime: end,
        service: serviceId,
        staffId,
        lastName: lastName || "",
        firstName: firstName || "",
        phone: phone || "",
        email,
        cutStyle,
        note,
        request,
        designated: isDesignated
      };
      
      const staffLabel = (designatedAttr === "true") ? "（指名）"
                        : (designatedAttr === "false") ? "" : "";
      const staffForModal = `${staff}${staffLabel}`;

      body.innerHTML = `
        <div><span class="fw-bold mb-1">日付：</span> ${formatDateWithWeekday(date)}</div>
        <div><span class="fw-bold mb-1">開始時間：</span> ${start}</div>
        <div><span class="fw-bold mb-1">終了時間：</span> ${end}</div>
        <div><span class="fw-bold mb-1">サービス：</span> ${service}</div>
        <div><span class="fw-bold mb-1">担当者：</span> ${staffForModal}</div>
        <div><span class="fw-bold mb-1">予約者名：</span> ${name}</div>
        <div><span class="fw-bold mb-1">電話番号：</span> ${phone || "－"}</div>
        <div><span class="fw-bold mb-1">メール：</span> ${email || "－"}</div>
        <div><span class="fw-bold mb-1">カットスタイル：</span> ${cutStyle || "－"}</div>
        <div><span class="fw-bold mb-1">お客様からの要望：</span> ${ request ? escapeHtml(request) : "－" }</div>
        <div><span class="fw-bold">備考：</span> ${note || "－"}</div>
      `;


      new bootstrap.Modal(document.getElementById("viewConfirmModal")).show();
    }

      e.preventDefault(); // ページ遷移防止
    });
  }

  google.script.run.withSuccessHandler(data => {
    const select = document.getElementById("customer-select");
    if (!select) return;

    data.forEach(cust => {
      const option = document.createElement("option");
      option.value = `${cust.lastName}|${cust.firstName}|${cust.tel}|${cust.email}`;
      option.textContent = `${cust.lastName} ${cust.firstName}`;
      select.appendChild(option);
    });

    select.addEventListener("change", e => {
      const [last, first, tel, email] = e.target.value.split("|");
      document.getElementById("lastNameInput").value = last || "";
      document.getElementById("firstNameInput").value = first || "";
      document.getElementById("phoneInput").value = tel || "";
      document.getElementById("emailInput").value = email || "";
    });
  }).getCustomerList();

  google.script.run
    .withSuccessHandler(allData => {
      weeklyDataCache = allData;
      weeklyCache[startStr] = allData;

      isSingleStaffMode = allData?.meta?.staffList?.length === 1;

      if (isSingleStaffMode) {
        document.getElementById("display-mode-toggle").style.display = "none";
        document.getElementById("service-tabs").style.display = "none";

        setupCategorySelect();
        updateLabel();
        const staff = allData.meta.staffList[0];
        drawTableByStaff(allData.staffView[staff.id], staff.id);
        adjustTableMinWidth();
      } else {
        document.getElementById("display-mode-toggle").style.display = "block";
        document.getElementById("service-tabs").style.display = "flex";

        const savedMode = localStorage.getItem("calendarMode") || "staff";
        currentMode = savedMode;
        setToggleUI(savedMode);
        setupCategorySelect(); 
        initTabs(savedMode);
      }
      hideReservationOverlay();
    })

    .withFailureHandler(err => {
      document.getElementById("table-area").innerHTML = `<div class='text-danger'>読み込みエラー: ${err.message}</div>`;
    })
    .getWeeklyMatrixUnified(startStr);
});



let resizeTimer;
window.addEventListener("resize", () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(() => {
    const startStr = formatDate(currentStartDate);
    const allData = weeklyCache[startStr];
    if (!allData) return;

    if (isSingleStaffMode) {
      const staff = allData.meta.staffList[0];
      drawTableByStaff(allData.staffView[staff.id], staff.id);
    } else {
      const mode = currentMode;
      const activeTab = document.querySelector("#service-tabs .active");

      if (mode === "service" && activeTab) {
        const serviceId = activeTab.dataset.serviceId;
        drawTable(allData.services[serviceId], serviceId);
      }

      if (mode === "staff" && activeTab) {
        const staffId = activeTab.dataset.staffId;
        drawTableByStaff(allData.staffView[staffId], staffId);
      }
    }

    // ✅ 再描画のあとに width 調整をかける
    setTimeout(() => {
      adjustTableMinWidth();
    }, 50); // 少し遅らせて反映させる
  }, 150);
});

function populateCustomerSelect() {
  if (!cachedCustomerList || cachedCustomerList.length === 0) return;
  renderCustomerSelect(cachedCustomerList, "customer-select");
}


function renderCustomerSelect(customers, selectId = "customer-select", prefix = "") {
  const select = document.getElementById(selectId);
  if (!select) return;

  select.innerHTML = '<option value="">-- 新規顧客 --</option>';

  const gojuonMap = {
    ア: "ア行", イ: "ア行", ウ: "ア行", エ: "ア行", オ: "ア行",
    カ: "カ行", キ: "カ行", ク: "カ行", ケ: "カ行", コ: "カ行",
    サ: "サ行", シ: "サ行", ス: "サ行", セ: "サ行", ソ: "サ行",
    タ: "タ行", チ: "タ行", ツ: "タ行", テ: "タ行", ト: "タ行",
    ナ: "ナ行", ニ: "ナ行", ヌ: "ナ行", ネ: "ナ行", ノ: "ナ行",
    ハ: "ハ行", ヒ: "ハ行", フ: "ハ行", ヘ: "ハ行", ホ: "ハ行",
    マ: "マ行", ミ: "マ行", ム: "マ行", メ: "マ行", モ: "マ行",
    ヤ: "ヤ行", ユ: "ヤ行", ヨ: "ヤ行",
    ラ: "ラ行", リ: "ラ行", ル: "ラ行", レ: "ラ行", ロ: "ラ行",
    ワ: "ワ行", ヲ: "ワ行", ン: "ワ行"
  };

  const grouped = {};
  customers.forEach(c => {
    const kana = (c.lastKana || "").normalize("NFKC").replace(/[^ァ-ン]/g, "");
    const firstChar = kana.charAt(0);
    const baseChar = firstChar.replace(/[ガギグゲゴ]/, "カ")
                              .replace(/[ザジズゼゾ]/, "サ")
                              .replace(/[ダヂヅデド]/, "タ")
                              .replace(/[バビブベボ]/, "ハ")
                              .replace(/[パピプペポ]/, "ハ");
    const group = gojuonMap[baseChar] || "その他";
    if (!grouped[group]) grouped[group] = [];
    grouped[group].push(c);
  });

  const gojuonOrder = ["ア行", "カ行", "サ行", "タ行", "ナ行", "ハ行", "マ行", "ヤ行", "ラ行", "ワ行", "その他"];
  gojuonOrder.forEach(group => {
    if (!grouped[group]) return;
    const optGroup = document.createElement("optgroup");
    optGroup.label = group;
    grouped[group].forEach(c => {
      const option = document.createElement("option");
      option.value = (c.phone || "").replace(/-/g, "");
      option.textContent = `${c.lastName} ${c.firstName}`;
      optGroup.appendChild(option);
    });
    select.appendChild(optGroup);
  });

  select.addEventListener("change", function () {
    const selected = cachedCustomerList.find(c => (c.phone || "").replace(/-/g, "") === this.value);

    document.getElementById(`${prefix}lastNameInput`).value = selected ? selected.lastName : "";
    document.getElementById(`${prefix}firstNameInput`).value = selected ? selected.firstName : "";
    document.getElementById(`${prefix}phoneInput`).value = selected ? selected.phone : "";
    document.getElementById(`${prefix}emailInput`).value = selected ? selected.email : "";
  });
}

/*　=============================================================================================== */
/*　                                        テーブル表示系　　                                         */
/*　=============================================================================================== */

function saveScrollPosition(mode, id) {
  const el = document.querySelector('.table-wrap');
  if (!el || !mode || !id) return;
  const key = `${mode}_${id}`;
  scrollMemory[key] = {
    left: el.scrollLeft,
    top: el.scrollTop
  };
}

function restoreScrollPosition(mode, id) {
  const el = document.querySelector('.table-wrap');
  if (!el || !mode || !id) return;
  const key = `${mode}_${id}`;
  const pos = scrollMemory[key];
  if (pos) {
    el.scrollTo(pos.left, pos.top);
  }
}

function resetScrollMemory() {
  scrollMemory = { service: {}, staff: {} };
}

function scrollToAndHighlight(date, time, staffId, serviceId) {
  const selector = `[data-date="${date}"][data-time="${time}"][data-staff-id="${staffId}"][data-service-id="${serviceId}"]`;
  const target = document.querySelector(selector);
  if (!target) return;

  target.classList.add("highlighted");
  //target.scrollIntoView({ behavior: "smooth", block: "center" });

  setTimeout(() => {
    target.classList.remove("highlighted");
  }, 3000);
}

// カテゴリ状態（管理画面はデフォルト“すべて”）
let activeCategoryMain = localStorage.getItem("activeCategoryMain") || "__ALL__";

// カテゴリセレクトの構築・表示制御
function setupCategorySelect() {
  const wrap = document.getElementById("category-main-wrap");
  const sel  = document.getElementById("category-main-select");

  wrap.style.display = "none";
  sel.innerHTML = "";

  const cats = (weeklyDataCache?.meta?.categories || []).filter(v => String(v).trim() !== "");
  if (cats.length === 0) {
    activeCategoryMain = "__ALL__";
    return;
  }

  sel.innerHTML = [
    `<option value="__ALL__">すべて</option>`,
    ...cats.map(c => `<option value="${c}">${c}</option>`)
  ].join("");

  if (![ "__ALL__", ...cats ].includes(activeCategoryMain)) {
    activeCategoryMain = "__ALL__";
  }
  sel.value = activeCategoryMain;
  wrap.style.display = "block";

  sel.onchange = () => {
    activeCategoryMain = sel.value || "__ALL__";
    localStorage.setItem("activeCategoryMain", activeCategoryMain);

    // ★ SingleStaffMode ではスタッフカレンダーに固定
    if (isSingleStaffMode) {
      if (currentMode !== "staff") {
        currentMode = "staff";
        setToggleUI("staff");
        localStorage.setItem("calendarMode", "staff");
      }
      initTabs("staff");
    } else {
      initTabs(currentMode);
    }
  };
}


// カテゴリでサービス配列を絞り込む
function filterServicesByActiveCategory(services) {
  if (!Array.isArray(services)) return [];
  if (activeCategoryMain === "__ALL__") return services;
  const metaList = (weeklyDataCache?.meta?.serviceList) || [];
  const catMap = Object.fromEntries(metaList.map(s => [s.id, s.categoryMain || ""]));
  return services.filter(s => {
    const cat = (s.categoryMain ?? catMap[s.id] ?? "");
    return cat === activeCategoryMain;
  });
}

function initTabs(mode) {
  const startStr = formatDate(currentStartDate);
  const allData = weeklyCache[startStr];
  if (!allData) {
    console.warn("🚫 キャッシュに該当データがない", startStr);
    return;
  }

  weeklyDataCache = allData;
  const tabsContainer = document.getElementById("service-tabs");
  tabsContainer.innerHTML = "";
  updateLabel();
  showLoadingSpinner();

  if (mode === "service") {
    const serviceList = filterServicesByActiveCategory(
      [...allData.meta.serviceList].sort((a, b) => (a.order || 0) - (b.order || 0))
    );

    const savedServiceId = localStorage.getItem("defaultServiceId") || serviceList[0]?.id;
    let found = false;

    serviceList.forEach(service => {
      const btn = document.createElement("button");
      btn.className = "btn btn-outline-primary";
      btn.dataset.serviceId = service.id;
      // name は小カテゴリ (categorySub) が入ってる想定
      btn.textContent = service.categorySub || service.name || service.id;

      if (service.id === savedServiceId) {
        btn.classList.add("active");
        found = true;
      }

      btn.addEventListener("click", () => {
        saveScrollPosition("service", localStorage.getItem("defaultServiceId"));

        document.querySelectorAll('#service-tabs button').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        drawTable(allData.services[service.id], service.id);
        adjustTableMinWidth();
        localStorage.setItem("defaultServiceId", service.id);

        restoreScrollPosition("service", service.id);
      });

      tabsContainer.appendChild(btn);
    });

    const targetId = found ? savedServiceId : serviceList[0].id;
    drawTable(allData.services[targetId], targetId);
    adjustTableMinWidth();
    const targetBtn = document.querySelector(`#service-tabs button[data-service-id="${targetId}"]`);
    if (targetBtn) targetBtn.classList.add("active");
    restoreScrollPosition("service", targetId);
    highlightSavedSlotOnly();
  }

  if (mode === "staff") {
  const staffList = allData.meta.staffList;
  let savedStaffId = localStorage.getItem("defaultStaffId");

  const isValidStaffId = staffList.some(s => s.id === savedStaffId);
  if (!isValidStaffId) {
    savedStaffId = staffList[0]?.id;
    localStorage.setItem("defaultStaffId", savedStaffId);
  }

  staffList.forEach(staff => {
    const btn = document.createElement("button");
    btn.className = "btn btn-outline-primary";
    btn.dataset.staffId = staff.id;
    btn.textContent = staff.name || staff.id;

    if (staff.id === savedStaffId) {
      btn.classList.add("active");
    }

    btn.addEventListener("click", () => {
      saveScrollPosition("staff", localStorage.getItem("defaultStaffId"));

      document.querySelectorAll('#service-tabs button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      drawTableByStaff(allData.staffView[staff.id], staff.id);
      adjustTableMinWidth();
      localStorage.setItem("defaultStaffId", staff.id);

      restoreScrollPosition("staff", staff.id);
      highlightSavedSlotOnly();
    });

    tabsContainer.appendChild(btn);
  });

  drawTableByStaff(allData.staffView[savedStaffId], savedStaffId);
  adjustTableMinWidth();
  const firstBtn = document.querySelector(`#service-tabs button[data-staff-id="${savedStaffId}"]`);
  if (firstBtn) firstBtn.classList.add("active");
}



  isLoading = false;
}

function formatDate(d) {
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  const day = String(d.getDate()).padStart(2, "0");
  return `${y}-${m}-${day}`;
}

function updateLabel() {
  const end = new Date(currentStartDate);
  end.setDate(currentStartDate.getDate() + 6);

  const options = { month: 'numeric', day: 'numeric', weekday: 'short' };
  const startStr = currentStartDate.toLocaleDateString('ja-JP', options);
  const endStr = end.toLocaleDateString('ja-JP', options);

  const yearStr = `${currentStartDate.getFullYear()}年`;

  document.getElementById("week-label").textContent = `${yearStr} ${startStr}〜${endStr}`;
}

function changeWeek(deltaDays) {      // deltaDays は -7 / +7 を想定
  if (isLoading) return;
  currentStartDate = toStartOfDayJST(new Date(currentStartDate.getTime() + deltaDays * 86400000));

  const key = formatDate(toStartOfDayJST(currentStartDate));
  if (weeklyCache[key]) {
    weeklyDataCache = weeklyCache[key];
    initTabs(currentMode);            // ← 既存の再描画入口
  } else {
    isLoading = true;
    showReservationOverlay("予約データ取得中…");
    google.script.run
      .withSuccessHandler(data => {
        hideReservationOverlay();
        isLoading = false;
        weeklyCache[key] = data;
        weeklyDataCache = data;
        setupCategorySelect(); 
        initTabs(currentMode);
      })
      .withFailureHandler(err => {
        hideReservationOverlay();
        isLoading = false;
        alert("❌ データ取得に失敗しました：" + err.message);
      })
      .getWeeklyMatrixUnified(key);   // ← すでに当日起点対応済み（サーバ）
  }
}

function handleDateSelect() {
  const v = document.getElementById("date-picker").value;
  if (!v) return;
  currentStartDate = toStartOfDayJST(v);
  const key = formatDate(toStartOfDayJST(currentStartDate));
  if (weeklyCache[key]) {
    weeklyDataCache = weeklyCache[key];
    initTabs(currentMode);
  } else {
    // 上と同様に取得
    isLoading = true;
    showReservationOverlay("予約データ取得中…");
    google.script.run
      .withSuccessHandler(data => {
        hideReservationOverlay();
        isLoading = false;
        weeklyCache[key] = data;
        weeklyDataCache = data;
        setupCategorySelect(); 
        initTabs(currentMode);
      })
      .withFailureHandler(err => {
        hideReservationOverlay();
        isLoading = false;
        alert("❌ データ取得に失敗しました：" + err.message);
      })
      .getWeeklyMatrixUnified(key);
  }
}

function showLoadingSpinner() {
  document.getElementById("table-area").innerHTML = `
    <div class="text-center my-3">
      <div class="spinner-border text-primary" role="status">
        <span class="visually-hidden">読み込み中...</span>
      </div>
      <p class="mt-3">空き状況カレンダー作成中…</p>
    </div>`;
}


function toMinutes(timeStr) {
  const [h, m] = timeStr.split(":").map(Number);
  return h * 60 + m;
}

// ✅ スマホ判定関数
function isMobile() {
  return window.matchMedia("(max-width: 576px)").matches;
}

// ✅ スマホだけ縦表示に変換
function verticalName(name) {
  if (!name) return "";
  return String(name).split("").join("<br>");
}

// ✅ モバイルなら縦、PCはそのまま
function getDisplayName(name) {
  return name || "";
}

function adjustTableMinWidth() {
  const table = document.querySelector('.table');
  if (!table) return;

  if (window.innerWidth <= 576) {
    const colCount = table.querySelectorAll('thead tr:nth-child(2) th').length;
    const widthPerCol = 40;
    const totalWidth = colCount * widthPerCol;
    table.style.minWidth = `${totalWidth}px`;
    table.style.width = "unset"; // ← 💡強制上書きされた100%を無効化
  } else {
    table.style.minWidth = "";
    table.style.width = "";
  }
}

function generateSlotTimesFromHours(businessHourMap, unitMinutes) {
  let minMinutes = 1440;
  let maxMinutes = 0;

  for (const date in businessHourMap) {
    const ranges = businessHourMap[date] || [];
    for (const r of ranges) {
      if (!r.start || !r.end) continue;
      const [sh, sm] = r.start.split(":").map(Number);
      const [eh, em] = r.end.split(":").map(Number);
      const startMin = sh * 60 + sm;
      const endMin = eh * 60 + em;

      if (!isNaN(startMin) && startMin < minMinutes) minMinutes = startMin;
      if (!isNaN(endMin) && endMin > maxMinutes) maxMinutes = endMin;
    }
  }

  const slots = [];
  for (let m = minMinutes; m < maxMinutes; m += unitMinutes) {
    const h = Math.floor(m / 60).toString().padStart(2, "0");
    const min = (m % 60).toString().padStart(2, "0");
    slots.push(`${h}:${min}`);
  }

  return slots;
}

function getSlotHeight(unitMin) {
  if (unitMin <= 10) return 28;
  if (unitMin <= 15) return 36;
  if (unitMin <= 30) return 48;
  if (unitMin <= 60) return 60;
  return 72; // 90分以上
}

function generateEndTime(startTime, rowspan, unitMin, timeSlots) {
  const startIndex = timeSlots.indexOf(startTime);
  const endIndex = startIndex + rowspan;
  if (endIndex >= timeSlots.length) {
    // 最後のスロット超える → 自力で計算
    const [h, m] = startTime.split(":").map(Number);
    const totalMinutes = h * 60 + m + rowspan * unitMin;
    const hh = Math.floor(totalMinutes / 60).toString().padStart(2, "0");
    const mm = (totalMinutes % 60).toString().padStart(2, "0");
    return `${hh}:${mm}`;
  }
  return timeSlots[endIndex];
}

// 営業/休憩を考慮して、この日時が“開いているか”判定
// businessHourMap 例：
//  - 曜日キー: { "0":[{start:"10:00",end:"20:00",type:"営業"},{start:"13:00",end:"14:00",type:"休憩"}], ... }
//  - 日付キー: { "2025-08-09":[{start:"10:00",end:"19:00",type:"営業"}], ... }
// どちらもあれば両方を合算（営業は追加、休憩/休業は上書きで閉じる）
function isOpenAt(dateStr, t, businessHourMap) {
  if (!businessHourMap) return true; // 不明なら壊さない（従来互換）

  const toMin = (hhmm) => {
    if (!hhmm) return null;
    const [h, m] = hhmm.split(":").map(Number);
    return (h ?? 0) * 60 + (m ?? 0);
  };
  const covers = (rule, tMin) => {
    // start/end 未指定は「終日」扱い
    const s = toMin(rule.start) ?? 0;
    const e = toMin(rule.end) ?? 24 * 60;
    return tMin >= s && tMin < e;
  };

  const d = new Date(dateStr);
  const dow = d.getDay();
  const tMin = toMin(t);

  // 使うルールを集める（曜日テンプレ＋日付個別）
  const flat = [];
  const pushArr = (arr) => { if (Array.isArray(arr)) for (const r of arr) if (r) flat.push(r); };
  pushArr(businessHourMap[dow] || businessHourMap[String(dow)]);
  pushArr(businessHourMap[dateStr]);

  // ルールが全く無ければ “開店中” とみなす（従来互換）
  if (flat.length === 0) return true;

  // タイプ判定
  const isOnType = (type) => {
    const s = String(type ?? "").trim();
    // 「営業」を含むものを ON と解釈
    return s.includes("営");
  };
  const isOffType = (type) => {
    const s = String(type ?? "").trim();
    // 「休」「休憩」「閉」等を OFF と解釈（例：休憩/休業/休店/閉店/店休 など）
    return s.includes("休") || s.includes("閉");
  };

  // t をカバーする ON と OFF を判定
  let on = false;
  let off = false;
  for (const r of flat) {
    if (!covers(r, tMin)) continue;
    if (isOnType(r.type ?? r.用途)) on = true;
    if (isOffType(r.type ?? r.用途)) off = true;
  }

  // ルールに一切該当しなければ閉じているとは言い切れないので、従来互換で true
  // どれかに該当した場合は「ON かつ OFF でない」時だけ開店中
  return (on || (!on && !off && flat.length === 0)) ? (!off && on) : (!off && on);
}

function drawTable(data, serviceId = "") {
  const t0 = performance.now();

  const businessHourMap = data["_meta"].businessHours || {};
  const unitMin = data["_meta"].unitMin || 60;
  const slotHeight = getSlotHeight(unitMin); //スロットの高さ調整用

  document.documentElement.style.setProperty('--slot-height', `${slotHeight}px`);

  const timeSlots = generateSlotTimesFromHours(data["_meta"].businessHours || {}, unitMin);
  const staffColumnMap = data["_meta"].staffColumnMap || {};
  const dates = Object.keys(data).filter(k => k !== "_meta").sort((a, b) => new Date(a) - new Date(b));
  const skipMap = {};

  // ✅ メタから名前→IDを確定
  const metaStaff = (data["_meta"]?.staff || []).reduce((m, s) => {
    if (s?.name) m[s.name] = s.id;
    return m;
  }, {});

  for (let dateStr of dates) {
    const serviceMeta = data["_meta"]?.services?.find(s => s.id === serviceId);
    const capacity = serviceMeta?.capacity || 1;
    const staffList = staffColumnMap[dateStr] || [];
    const staffCount = staffList.length;

    for (let t of timeSlots) {
      if (!data[dateStr]) data[dateStr] = {};
      if (!data[dateStr][t]) data[dateStr][t] = [];

      const slotArray = data[dateStr][t];
      skipMap[dateStr] = skipMap[dateStr] || {};

      for (let s = 0; s < staffCount; s++) {
        const staffName = staffList[s];
        const staffId = metaStaff[staffName] || "";
        const baseIndex = s * capacity;

        // このスタッフのセグメントだけ切り出し
        const segStart = baseIndex;
        const segEnd = baseIndex + capacity; // 非包含
        const segCells = slotArray.slice(segStart, segEnd);

        const isDash = (v) => v === "－" || v === "−" || v === "-";
        const isBookedCell = (c) => {
          if (!c) return false;
          const name = c?.name ?? "";
          const status = c?.status ?? "";
          // 「🟢/－/×/空」以外の表示（予約者名等）は予約扱い
          const byName = name && !["🟢", "×"].includes(name) && !isDash(name);
          const byStatus = status && !["🟢", "×"].includes(status) && !isDash(status);
          return byName || byStatus;
        };

        // 行（時刻）全体の営業判定（休憩も閉扱い）
        const openNow = isOpenAt(dateStr, t, businessHourMap);

        // 現在時刻のセグメント状態
        const segDefined = segCells.filter(c => c != null);
        const segHasGreen = segDefined.some(c => (c?.name === "🟢") || (c?.status === "🟢"));
        const segHasBooked = segDefined.some(isBookedCell);
        const segAllDashNow = segDefined.length > 0 && segDefined.every(c => isDash(c?.name) || isDash(c?.status));

        // 直前/直後スロットのセグメントも参照（“不在の帯” の判定に使う）
        const timeIndex = timeSlots.indexOf(t);
        const prevTime = timeSlots[timeIndex - 1];
        const nextTime = timeSlots[timeIndex + 1];
        const segAllDashFor = (row) => {
          if (!Array.isArray(row)) return false;
          const cells = row.slice(segStart, segEnd).filter(c => c != null);
          return cells.length > 0 && cells.every(c => isDash(c?.name) || isDash(c?.status));
        };
        const prevSegAllDash = prevTime ? segAllDashFor(data[dateStr]?.[prevTime] || []) : false;
        const nextSegAllDash = nextTime ? segAllDashFor(data[dateStr]?.[nextTime] || []) : false;

        // 補完マーク決定：
        // 1) 営業時間外 → 常に "－"
        // 2) 営業時間内かつ “今〜次も不在帯（全ハイフン）” で、今は予約だけ入っている → 不在中のイレギュラー予約 → "－"
        // 3) 営業時間内かつ 予約あり → 稼働中 → "🟢"
        // 4) 営業時間内かつ 明確に全ハイフンのみ → "－"
        // 5) それ以外 → "🟢"
        let fillMark;
        if (!openNow) {
          fillMark = "－";
        } else if (segHasBooked && !segHasGreen && (segAllDashNow || nextSegAllDash)) {
          // 例: 18:00 が不在帯で予約入り、18:15 も不在帯 → 残りは －
          fillMark = "－";
        } else if (segHasBooked) {
          // 例: 19:00 で出勤開始＆予約あり → 残りは 🟢
          fillMark = "🟢";
        } else if (!segHasGreen && segAllDashNow) {
          fillMark = "－";
        } else {
          fillMark = "🟢";
        }

        for (let c = 0; c < capacity; c++) {
          const i = baseIndex + c;
          if (!slotArray[i]) {
            slotArray[i] = { staffId, name: fillMark, duration: unitMin };
          }
        }
      }

      // ★ 継続列を避けて新規開始を横移動（rowspan直前）
      {
        const timeIndex = timeSlots.indexOf(t);
        const prevTime = timeSlots[timeIndex - 1];

        const isDash = v => v === "－" || v === "−" || v === "-";
        const isBooked = c => {
          if (!c) return false;
          const n = (c.name || "").trim();
          const st = (c.status || "").trim();
          return (n && !["🟢","×"].includes(n) && !isDash(n)) ||
                (st && !["🟢","×"].includes(st) && !isDash(st));
        };

        for (let s = 0; s < staffCount; s++) {
          const segStart = s * capacity;
          const segEnd   = segStart + capacity;

          for (let i = segStart; i < segEnd; i++) {
            const cell = slotArray[i];
            if (!isBooked(cell)) continue;

            // 前行と同じ予約なら継続＝そのまま
            const prevCell = prevTime ? (data[dateStr]?.[prevTime]?.[i]) : null;
            const continuing = prevCell && isBooked(prevCell) &&
                              (prevCell.name === cell.name) &&
                              ((prevCell.phone || "") === (cell.phone || ""));
            if (continuing) continue;

            // この列は上からのrowspanで塞がれてる？
            const blockedHere = !!(skipMap[dateStr]?.[`${t}-${i}`]);
            if (!blockedHere) continue;

            // 同スタッフのセグメント内で、塞がれてなくて“予約が置かれていない”列へスライド
            for (let j = segStart; j < segEnd; j++) {
              if (j === i) continue;
              if (skipMap[dateStr]?.[`${t}-${j}`]) continue;      // ここも継続で塞がりならNG
              const dst = slotArray[j];
              if (!isBooked(dst)) {                                // 🟢/－/空 なら受け皿OK
                slotArray[j] = cell;
                slotArray[i] = { staffId: cell.staffId || "", name: "🟢", duration: unitMin };
                break;
              }
            }
          }
        }
      }

      // 🔁 rowspan 処理
        for (let i = 0; i < slotArray.length; i++) {
          const cell = slotArray[i];
          // 予約セルだけ縦にスキップ付与（🟢/－/空 以外）
          if (cell && cell.name && !["🟢", "🔘", "－", ""].includes(cell.name)) {
            const timeIndex = timeSlots.indexOf(t);
            const rowspan = (cell.duration || 0) / unitMin;

            for (let j = 1; j < rowspan; j++) {
              const nextTime = timeSlots[timeIndex + j];
              if (!nextTime) continue;

              skipMap[dateStr][`${nextTime}-${i}`] = true;

              if (!data[dateStr][nextTime]) data[dateStr][nextTime] = [];
              const nextSlotArray = data[dateStr][nextTime];

              while (nextSlotArray.length <= i) {
                // 列 i → スタッフを逆算して staffId を安定付与
                const staffIdx = Math.floor(i / capacity);
                const staffName2 = (staffColumnMap[dateStr] || [])[staffIdx] || "";
                const staffId2 = metaStaff[staffName2] || "";
                nextSlotArray.push({ staffId: staffId2, name: "－", duration: unitMin });
              }
            }
          }
        }
      }
  }
  

  const htmlParts = [];
  htmlParts.push('<div class="table-wrap"><table class="table table-bordered table-fixed text-center">');
  htmlParts.push('<thead class="table-light"><tr><th rowspan="2">時間</th>');

  const holidaySet = new Set(weeklyDataCache?.meta?.holidays || []);

  for (let dateStr of dates) {
    const d = new Date(dateStr);
    const dow = d.getDay();

    // デフォルト（日曜赤、土曜青）
    let dayColor = "";
    if (dow === 0) dayColor = "text-danger";
    else if (dow === 6) dayColor = "text-primary";

    // 👇 祝日だったら日曜と同じ赤に上書き
    if (holidaySet.has(dateStr)) {
      dayColor = "text-danger";
    }

    const sampleRow = data[dateStr]?.[timeSlots[0]] || [];
    const colSpan = sampleRow.length || 1;

    htmlParts.push(
      `<th colspan="${colSpan}">
        <span class="${dayColor}">
          ${d.getMonth() + 1}/${d.getDate()}
          <span class="day-split">(${["日", "月", "火", "水", "木", "金", "土"][dow]})</span>
        </span>
      </th>`
    );
  }

  htmlParts.push('</tr><tr>');

  // スタッフ名行
  for (let dateStr of dates) {
    const staffListRaw = staffColumnMap[dateStr] || [];
    const capacity = data["_meta"]?.services?.find(s => s.id === serviceId)?.capacity || 1;

    for (const name of staffListRaw) {
      htmlParts.push(`<th class="small text-secondary staff-name-cell" colspan="${capacity}">${name}</th>`);
    }
  }

  htmlParts.push('</tr></thead><tbody>');

  for (let t of timeSlots) {
    const borderClass = t.endsWith(":00") ? "border-solid" : "border-dotted";
    htmlParts.push(`<tr><th class="${borderClass}">${t}</th>`);

    for (let dateStr of dates) {
      skipMap[dateStr] = skipMap[dateStr] || {};
      const slotArray = data[dateStr]?.[t] || [];
      const fixedCols = ((staffColumnMap[dateStr] || []).length) * ((data["_meta"]?.services?.find(s => s.id === serviceId)?.capacity) || 1) || 1;

      for (let i = 0; i < fixedCols; i++) {
        const skipKey = `${t}-${i}`;
        if (skipMap[dateStr][skipKey]) continue;

        const cell = slotArray[i];
        const staffId = cell?.staffId || "";

        const timeIndex = timeSlots.indexOf(t);
        const rowspan = (cell?.duration || 0) / unitMin;

        if (cell && !["🟢", "🔘", "－", "", "〇"].includes(cell.name)) {
          for (let j = 1; j < rowspan; j++) {
            const nextTime = timeSlots[timeIndex + j];
            if (nextTime) skipMap[dateStr][`${nextTime}-${i}`] = true;
          }
          const nameClass = isMobile() ? 'vertical-name' : '';
          htmlParts.push(`<td class="badge-booked ${borderClass} text-center bg-white selectable-cell" rowspan="${rowspan}"
            data-date="${dateStr}" data-time="${t}" data-service-id="${serviceId}"
            data-staff-id="${staffId}" data-name="${cell.name}"
            data-start="${t}" data-end="${generateEndTime(t, rowspan, unitMin, timeSlots)}"
            data-phone="${cell.phone || ''}" data-email="${cell.email || ''}"
            data-cutstyle="${cell.cutStyle || ''}" data-note="${cell.note || ''}"
            data-request="${(cell.request || '').replace(/"/g,'&quot;')}"
            data-designated="${cell.designated ? 'true' : 'false'}">
            <span class="text-body text-decoration-none ${nameClass}">${getDisplayName(cell.name)}</span></td>`);
        } else if (cell?.name === "🟢") {
          htmlParts.push(`<td class="${borderClass} text-center selectable-cell available-slot fw-bold text-success-light"
          data-date="${dateStr}" data-time="${t}"
          data-service-id="${serviceId}" data-staff-id="${staffId}">〇</td>`);
        } else if (cell?.status === "other-service") {
          htmlParts.push(`<td class="${borderClass} text-center bg-body-secondary other-reserved-slot text-muted selectable-cell"
            data-date="${dateStr}" data-time="${t}"
            data-service-id="${serviceId}" data-staff-id="${staffId}">×</td>`);
        } else {
          htmlParts.push(`<td class="${borderClass} bg-body-secondary text-muted text-center selectable-cell"
            data-date="${dateStr}" data-time="${t}"
            data-service-id="${serviceId}" data-staff-id="${staffId}">－</td>`);
        }
      }
    }
    htmlParts.push('</tr>');
  }

  htmlParts.push('</tbody></table></div>');
  document.getElementById("table-area").innerHTML = htmlParts.join("");

  // ✅ イベントバインド（1回だけ・イベントデリゲーション）
  const tableArea = document.getElementById("table-area");
  tableArea.removeEventListener("click", handleCellClick); // 二重登録防止
  tableArea.addEventListener("click", handleCellClick);

  restoreScrollPosition("service", serviceId);

  // スクロール保存（デバウンス）
  (function attachWrapScrollSaver(){
    const wrap = document.querySelector('.table-wrap');
    if (!wrap) return;
    let t;
    wrap.removeEventListener('scroll', wrap.__saveHandler || (()=>{}));
    wrap.__saveHandler = function() {
      clearTimeout(t);
      t = setTimeout(persistScrollPosToLS, 150);
    };
    wrap.addEventListener('scroll', wrap.__saveHandler, { passive: true });
  })();

}

function drawTableByStaff(data, staffId) {
  if (!data || !data["_meta"]) {
    console.warn("drawTableByStaff: invalid data", { staffId, data });
    const fallback = weeklyDataCache?.staffView?.[staffId];
    if (!fallback) return; // これ以上できない
    data = fallback;
  }
  const t0 = performance.now();

  const unitMin = data["_meta"].unitMin || 60;
  const slotHeight = getSlotHeight(unitMin); // スロットの高さ調整用
  document.documentElement.style.setProperty('--slot-height', `${slotHeight}px`);

  const timeSlots = generateSlotTimesFromHours(data["_meta"].businessHours || {}, unitMin);
  const allServices = data["_meta"].services || [];
  const services = filterServicesByActiveCategory(allServices);
  const dates = Object.keys(data).filter(k => k !== "_meta").sort((a, b) => new Date(a) - new Date(b));
  const skipMap = {};

  // 予約/空き判定（value は {status,startTime,endTime,phone,...}）
  const isDash = v => v === "－" || v === "−" || v === "-";
  const isBooked = v => !!v && !!v.status && !["🟢", "×"].includes(v.status) && !isDash(v.status);

  const htmlParts = [];
  htmlParts.push('<div class="table-wrap"><table class="table table-bordered table-fixed text-center">');
  htmlParts.push('<thead class="table-light"><tr><th rowspan="2">時間</th>');

  const holidaySet = new Set(weeklyDataCache?.meta?.holidays || []);

  for (let dateStr of dates) {
    const d = new Date(dateStr);
    const dow = d.getDay();

    let dayColor = "";
    if (dow === 0) dayColor = "text-danger";
    else if (dow === 6) dayColor = "text-primary";
    if (holidaySet.has(dateStr)) {
      dayColor = "text-danger";
    }
    let colSpan = 0;
    for (let s of services) {
      const val = data[dateStr]?.[timeSlots[0]]?.[s.id];
      if (Array.isArray(val)) colSpan += val.length; // capacity 本
    }
    htmlParts.push(
      `<th colspan="${colSpan}"><span class="${dayColor}">${d.getMonth() + 1}/${d.getDate()}<span class="day-split">(${["日","月","火","水","木","金","土"][dow]})</span></span></th>`
    );
  }

  // 見出し（サービス × capacity）
  htmlParts.push('</tr><tr>');
  for (let dateStr of dates) {
    for (let s of services) {
      const val = data[dateStr]?.[timeSlots[0]]?.[s.id];
      if (Array.isArray(val)) {
        for (let i = 0; i < val.length; i++) {
          htmlParts.push(
            `<th class="small text-secondary staff-name-cell">
              ${s.categorySub || s.name}${val.length > 1 ? " " + (i + 1) : ""}
            </th>`
          );
        }
      }
    }
  }
  htmlParts.push('</tr></thead><tbody>');

  // 本体
  for (let t of timeSlots) {
    const borderClass = t.endsWith(":00") ? "border-solid" : "border-dotted";
    htmlParts.push(`<tr><th class="${borderClass}">${t}</th>`);

    for (let dateStr of dates) {
      skipMap[dateStr] = skipMap[dateStr] || {};
      const serviceRow = data[dateStr]?.[t] || {};
      const timeIndex = timeSlots.indexOf(t);
      const prevTime = timeSlots[timeIndex - 1];

      for (let s of services) {
        const cells = serviceRow[s.id];
        if (!Array.isArray(cells)) continue;

        // ★ rowspan 直前の“横スライド”：この時刻 t で継続（上からの rowspan）で塞がった列に新規開始が乗ってたら、
        //    同サービス配列内（capacity 本）で塞がれていない＆未予約の列へ移動
        {
          // どの index が上から塞がってるか（skipMap）を把握
          const blockedIdx = new Set();
          for (let i = 0; i < cells.length; i++) {
            const key = `${t}-${s.id}-${i}`;
            if (skipMap[dateStr][key]) blockedIdx.add(i);
          }

          if (blockedIdx.size) {
            // “塞がってる列に置かれた予約”の index 一覧
            const moveTargets = [];
            for (let i = 0; i < cells.length; i++) {
              if (!blockedIdx.has(i)) continue;
              const v = cells[i];
              if (isBooked(v)) moveTargets.push(i);
            }

            if (moveTargets.length) {
              // 受け皿（塞がれておらず、未予約の列）を左から探して順に移す
              for (const from of moveTargets) {
                const v = cells[from];
                let moved = false;
                for (let j = 0; j < cells.length; j++) {
                  if (j === from) continue;
                  if (blockedIdx.has(j)) continue;         // ここも継続で塞がりならNG
                  const dst = cells[j];
                  if (!isBooked(dst)) {                     // 🟢/－/空 ならOK
                    cells[j] = v;
                    cells[from] = { status: "🟢", startTime: t, endTime: t, phone: v?.phone || "" };
                    moved = true;
                    break;
                  }
                }
                // 置き場が無い場合（capacity超過）はそのまま
              }
            }
          }
        }

        // ▼ ここから描画（rowspan を配る）
        for (let i = 0; i < cells.length; i++) {
          const skipKey = `${t}-${s.id}-${i}`;
          if (skipMap[dateStr][skipKey]) continue;

          const value = cells[i];

          if (!value || value.status === "−") {
            htmlParts.push(
              `<td class="${borderClass} bg-body-secondary text-muted text-center selectable-cell"
                 data-date="${dateStr}" data-time="${t}"
                 data-service-id="${s.id}" data-staff-id="${staffId}">－</td>`
            );
          } else if (value.status === "🟢") {
            htmlParts.push(
              `<td class="${borderClass} text-center selectable-cell available-slot fw-bold text-success-light"
                 data-date="${dateStr}" data-time="${t}"
                 data-service-id="${s.id}" data-staff-id="${staffId}">〇</td>`
            );
          } else if (value.status === "×") {
            htmlParts.push(
              `<td class="${borderClass} text-center bg-body-secondary other-reserved-slot text-muted selectable-cell"
                 data-date="${dateStr}" data-time="${t}"
                 data-service-id="${s.id}" data-staff-id="${staffId}">×</td>`
            );
          } else {
            // 予約セル
            const rowspan = (toMinutes(value.endTime) - toMinutes(value.startTime)) / unitMin;
            const idx = timeSlots.indexOf(t);

            // 未来行に skip を配る
            for (let j = 1; j < rowspan; j++) {
              const nt = timeSlots[idx + j];
              if (nt) skipMap[dateStr][`${nt}-${s.id}-${i}`] = true;
            }

            const nameClass = isMobile() ? "vertical-name" : "";
            htmlParts.push(
              `<td class="badge-booked ${borderClass} text-center selectable-cell" rowspan="${rowspan}"
                 data-date="${dateStr}" data-time="${t}"
                 data-service-id="${s.id}" data-staff-id="${staffId}"
                 data-name="${value.status}" data-phone="${value.phone || ''}"
                 data-start="${value.startTime}" data-end="${value.endTime}"
                 data-email="${value.email || ''}"
                 data-cutstyle="${value.cutStyle || ''}"
                 data-note="${value.note || ''}"
                 data-request="${(value.request || '').replace(/"/g,'&quot;')}"
                 data-designated="${value.designated ? 'true' : 'false'}">
                 <span class="text-body text-decoration-none ${nameClass}">${getDisplayName(value.status)}</span></td>`
            );
          }
        }
      } // services
    }   // dates

    htmlParts.push('</tr>');
  }     // timeSlots

  htmlParts.push('</tbody></table></div>');
  document.getElementById("table-area").innerHTML = htmlParts.join("");

  // クリックイベント（1回だけ）
  const tableArea = document.getElementById("table-area");
  tableArea.removeEventListener("click", handleCellClick);
  tableArea.addEventListener("click", handleCellClick);

  restoreScrollPosition("staff", staffId);

  // スクロール保存（デバウンス）
  (function attachWrapScrollSaver(){
    const wrap = document.querySelector('.table-wrap');
    if (!wrap) return;
    let t;
    wrap.removeEventListener('scroll', wrap.__saveHandler || (()=>{}));
    wrap.__saveHandler = function() {
      clearTimeout(t);
      t = setTimeout(persistScrollPosToLS, 150);
    };
    wrap.addEventListener('scroll', wrap.__saveHandler, { passive: true });
  })();

}

function handleCellClick(e) {
  const cell = e.target.closest("td");
  if (!cell || !cell.classList.contains("selectable-cell")) return;

  document.querySelectorAll('#table-area td').forEach(c => c.classList.remove('selected-cell'));
  cell.classList.add('selected-cell');
  // showReservationModal(cell.dataset); // 必要なら有効化
}

function showReservationOverlay(message = "予約処理中...") {
  const overlay = document.getElementById("reservation-overlay");
  if (overlay) {
    overlay.style.display = "flex";
    const messageDiv = overlay.querySelector(".overlay-message");
    if (messageDiv) {
      messageDiv.textContent = message;
    }
  }
}

function setupModalScrollListeners() {
  const elms = [
    "reserve-date",
    "start-time-select",
    "reserve-service",
    "reserve-staff",
  ];

  elms.forEach((id) => {
    const el = document.getElementById(id);
    if (el) {
      el.addEventListener("change", scrollToSelectedSlotInModal);
    }
  });
}

function scrollToSelectedSlotInModal() {
  const { date, time, staffId, serviceId, colIndex } = pendingReserveInfo || {};
  if (!date || !time || !staffId || !serviceId || colIndex == null) return;

  const selector = `[data-date="${date}"][data-time="${time}"][data-staff-id="${staffId}"][data-service-id="${serviceId}"]`;

  setTimeout(() => {
    const allMatches = document.querySelectorAll(selector);
    const target = allMatches[colIndex];  // ← 正しくクリックされた列をハイライト！
    const wrap = document.querySelector(".table-wrap");

    if (!target || !wrap) return;

    const targetRect = target.getBoundingClientRect();
    const wrapRect = wrap.getBoundingClientRect();

    wrap.scrollTo({
      top: wrap.scrollTop + (targetRect.top - wrapRect.top) - 100,
      left: wrap.scrollLeft + (targetRect.left - wrapRect.left) - 100,
      behavior: "smooth",
    });

    target.classList.add("highlighted");
    setTimeout(() => target.classList.remove("highlighted"), 3000);
  }, 200);
}


function activateTabByDataId(containerSelector, type, targetId) {

  const container = document.querySelector(containerSelector);
  if (!container) return;

  const tabs = container.querySelectorAll(`[data-${type}-id]`);

  let found = false;
  tabs.forEach(tab => {
    const id = tab.dataset[`${type}Id`];

    if (id === targetId) {
      tab.click();
      found = true;
    }
  });

  if (!found) {
    console.warn("❌ タブが見つかりませんでした！");
  }
}

function hideReservationOverlay() {
  const overlay = document.getElementById("reservation-overlay");
  if (overlay) overlay.style.display = "none";
}

function highlightSavedSlotOnly() {
  const action = (typeof consumeLastAction === "function"
    ? consumeLastAction()
    : (localStorage.getItem(LS_KEYS.lastAction) || ""));
  // 予約 or 削除 のときだけ実行
  if (action !== "reserve" && action !== "delete") {
    try { localStorage.removeItem(LS_KEYS.scroll); } catch {}
      return;
  }
  console.log("🧭 lastAction:", action);

  let mem = null;
  try { mem = JSON.parse(localStorage.getItem(LS_KEYS.scroll) || "null"); } catch {}
  const wrap = document.querySelector(".table-wrap");

  // スクロール復元
  try {
    const pos = JSON.parse(localStorage.getItem(LS_KEYS.scrollPos) || "null");
    if (wrap && pos && (pos.top != null || pos.left != null)) {
      wrap.scrollTo({ top: pos.top || 0, left: pos.left || 0, behavior: "instant" });
    }
  } catch {}

  if (!mem) return;
  console.log("🔍 scrollMemory:", mem);

  let target = null;

  // Step1: 完全一致セレクタ
  if (mem.selector) {
    console.log("🎯 Step1: querySelector ->", mem.selector);
    target = document.querySelector(mem.selector);
    console.log("🎯 Step1 result:", target);
  }

  // Step1b: serviceId が欠落/無効なときの段階的フォールバック
  if (!target && mem.meta) {
    const { date, time } = mem.meta;
    const staffId   = mem.meta.staffId || "";
    const serviceId = mem.meta.serviceId || "";
    const parts = [
      `[data-date="${date}"]`,
      `[data-time="${time}"]`,
    ];
    const withStaff  = staffId   ? parts.concat(`[data-staff-id="${staffId}"]`)   : parts.slice();
    const withSvc    = serviceId ? parts.concat(`[data-service-id="${serviceId}"]`): parts.slice();
    const withBoth   = (staffId && serviceId) ? parts.concat(`[data-staff-id="${staffId}"]`,`[data-service-id="${serviceId}"]`) : null;

    const candidates = [];
    if (withBoth) candidates.push(withBoth.join(""));
    candidates.push(withStaff.join(""));
    candidates.push(withSvc.join(""));
    candidates.push(parts.join("")); // 最後は date+time だけ

    for (const sel of candidates) {
      console.log("🧪 Step1b try:", sel);
      const el = document.querySelector(sel);
      if (el) { console.log("✅ Step1b hit:", sel, el); target = el; break; }
    }
  } 

  // Step2: 再探索（name/phone一致優先 & staff-id含めて絞る）
  if (!target && mem.meta) {
    const { date, time, end, staffId, serviceId, name, phone } = mem.meta;
    const baseSel =
      `[data-date="${date}"][data-time="${time}"]` +
      (staffId   ? `[data-staff-id="${staffId}"]`   : "") +
      (serviceId ? `[data-service-id="${serviceId}"]` : "");
    const list = document.querySelectorAll(baseSel);
    console.log(`📋 Step2候補: ${list.length} 件`, list);

    const clean = s => (s || "").replace(/[^\d]/g, "");
    const wantPhone = clean(phone);
    const wantName  = (name || "").trim();

    target = Array.from(list).find(el => {
      const get = (e, key) => e?.dataset?.[key]
        ?? e?.querySelector(`[data-${key}]`)?.dataset?.[key]
        ?? "";
      const elName  = (get(el, "name") || "").trim();
      const elPhone = clean(get(el, "phone"));
      const okName  = !!wantName  && elName  === wantName;
      const okPhone = !!wantPhone && elPhone === wantPhone;
      const okTime  = !time || String(get(el, "time")) === String(time);

      const match = okTime && (okName || okPhone);
      console[match ? "log" : "log"](match ? "✅ Step2マッチ:" : "🟨 Step2スキップ:", { el, elName, elPhone, wantName, wantPhone });
      return match;
    }) || null;
  }

  if (!target) {
    console.warn("⚠️ ハイライト対象が見つからなかった");
    try { localStorage.removeItem(LS_KEYS.scroll); } catch {}
    return;
  }

  // ✨ ハイライト処理（計測強化）
  const CLS = "selected-cell"; // ← CSSがあるクラスを使う
  console.log("✨ will highlight:", target);

  // 1) クラス付与
  target.classList.add(CLS);
  console.log("📦 class after add:", target.className);

  // 2) 次フレームでスタイル反映確認
  requestAnimationFrame(() => {
    const bg = getComputedStyle(target).backgroundColor;
    console.log("🎨 computed bg after add:", bg);

    // 2-a) DOMが書き換えられて消えてないか
    if (!document.contains(target)) {
      console.warn("🧨 targetがDOMから消えた（再描画に負けた可能性）。再待機→再実行します。");
      // 直前で参照できる mem を使う（関数先頭で取得済み）
      const { date, time, staffId, serviceId, name, phone, end } = mem.meta;

      // 再描画を待ちながら「本人」を再探索
      waitFor(() => {
        const list = document.querySelectorAll(
          `[data-date="${date}"][data-time="${time}"][data-service-id="${serviceId}"][data-staff-id="${staffId}"]`
        );
        const clean = s => (s || "").replace(/[^\d]/g, "");
        const wantPhone = clean(phone);
        const wantName  = (name || "").trim();

        const found = Array.from(list).find(el => {
          const get = (e, key) => e?.dataset?.[key]
            ?? e?.querySelector(`[data-${key}]`)?.dataset?.[key]
            ?? "";
          const elName  = (get(el, "name") || "").trim();
          const elPhone = clean(get(el, "phone"));
          // 名前 or 電話のどちらか一致を必須に
          return (!!wantName && elName === wantName) || (!!wantPhone && elPhone === wantPhone);
        });

        if (found) { window.__reFoundTarget = found; }
        return !!found;
      }, 1500, 50).then(() => {
        const t2 = window.__reFoundTarget;
        console.log("🔁 再取得 target(本人):", t2);
        if (t2) {
          t2.classList.add(CLS);
          setTimeout(() => t2.classList.remove(CLS), 3000);
        }
      }).catch(() => {
        console.warn("⏱ 再取得タイムアウト");
      });

      return;
    }

    // 2-b) 背景が白のまま等→CSS優先度負けの疑い → 一時的にインラインで塗る
    const isNoColor = !bg || bg === "rgba(0, 0, 0, 0)" || bg === "transparent" || bg === "rgb(255, 255, 255)";
    if (isNoColor) {
      console.warn("🧪 背景が効いてない→インラインで一時塗り");
      target.style.backgroundColor = "#ffeeba";
      target.style.outline = "2px solid #ffa000";
      target.style.boxShadow = "0 0 0 2px #ffa000 inset";
    }

    // 3) 自動解除
    setTimeout(() => {
      target.classList.remove(CLS);
      target.style.backgroundColor = "";
      target.style.outline = "";
      target.style.boxShadow = "";
    }, 3000);
  });

  try { localStorage.removeItem(LS_KEYS.scroll); } catch {}
}


// ⏱ "HH:mm" → 分数に変換
function toMinutes(str) {
  const [h, m] = str.split(":").map(Number);
  return h * 60 + m;
}
</script>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</div>
</body>
</html>

